# Hardware Check Functions

# ^^^^^^^^^^^^^^^^^^^^^ global constants ^^^^^^^^^^^^^^^^^^^^^^^^

raid_vendors='DELL INTEL LSI'

raid_models='PERC H700 SRCSAS144E MegaRAID 8888ELP MR9260DE-8i MR9260-8i MR9260-4i AOC-USAS2LP-H8iR Internal Dual SD PERC H730P Mini' 

raid_models_list=( "PERC H700" "PERC H710P" "SRCSAS144E" "MegaRAID 8888ELP" "MR9260DE-8i" "MR9260-8i" "MR9260-4i" "AOC-USAS2LP-H8iR" "Internal Dual SD" "PERC H730P Mini" )

pxetesthost='hwimgsrv.nw-xlabs'

# ^^^^^^^^^^^^^^^^^^^^^ global variables ^^^^^^^^^^^^^^^^^^^^^^^^^^

# type of netwitness software to install, parsed from kickstart %packages
nwapptype=

# anaconda install method: if set install is considered 'harddrive', otherwise 'cdrom' or 'url'
installtype=

# type of supported netwitness appliance hardware 
nwsystem=

# number of virtual drives on internal raid controller
numld=

# first drive validation test to run
drivetest=

# second drive validation test to run
drivetest2= 

# configure HW RAID
hwraid=

# S4S Newport System
inewport=

# Series 7 ESA, R630 w/6 drives 2@1TB & 4@2TB 
iseries7=

# installation logical block device list, alphabetical
declare -a installdev

# position of first planar ata block device in ${installdev[@]}
atablkdev=

# corresponding logical block devivce list's model
declare -a installmodel

# logcollector installation flag for upgrade package list
logcoll=

# nwwarehouseconnector installation flag for upgrade list and backup
warehouseconn=

# installation boot method uefi or msdos
bootmethod=

# Path of LSI MegaRaid CLI uility
COMMAND_TOOL=/usr/bin/CmdTool264

if ! [ -s $COMMAND_TOOL ] || ! [ -x $COMMAND_TOOL ]; then
	chvt 8 
	echo 
	echo ' -----------------------------------------------------'
	echo ' Usable LSI MegaRaid CLI utility Not found in /usr/bin' 
	echo ' installation cannot continue, exiting in 2 minutes'
	echo ' press <CTRL><ALT><DEL> to reboot now'
	echo ' -----------------------------------------------------'
	sleep 120
	chvt 1
	exit 1
fi 

# ^^^^^^^^^^^^^^^^^^^ function definitions ^^^^^^^^^^^^^^^^^^^^^^^

function chomp {
	
	local mystr="$1"
	local mylen
	local strchar
	rm -f /tmp/chompstr
	if [[ `echo "$mystr" | grep -E '[[:space:]]+$'` ]]; then
		while [ 1 ]
		do 
			let mylen="${#mystr}"
			strchar="${mystr:$mylen-1}"
			if [[ `echo "$strchar" | grep -E '[[:space:]]'` ]]; then
				mystr="${mystr:0:$mylen-1}"
			else
				break
			fi
		done
		echo "$mystr" > /tmp/chompstr
	fi
}

function mk_disk_labels {
# rewrite as well as initialize disk partition tables
	while ! [ -z $1 ] 
	do
		if ! [[ `ls -A /sys/block | grep "$1"` ]]; then
			echo "/dev/$1 device not found" >> /tmp/pre.log
			shift
			continue 
		fi
		
		if ! [ ${bootmethod} ]; then
			# make msdos labels to clear ghost data and initialize disks
			echo 'making default msdos disk label' >> /tmp/pre.log
			echo "/usr/sbin/parted -s /dev/$1 mklabel msdos" >> /tmp/pre.log
			/usr/sbin/parted -s /dev/${1} mklabel msdos >> /tmp/pre.log 2>&1
			echo 1 > /sys/block/${1}/device/rescan
		else
			# make gpt labels for uefi boot
			echo 'making gpt disk label' >> /tmp/pre.log
			echo "/usr/sbin/parted -s /dev/$1 mklabel gpt" >> /tmp/pre.log
			/usr/sbin/parted -s /dev/${1} mklabel gpt >> /tmp/pre.log 2>&1
			echo 1 > /sys/block/${1}/device/rescan		
		fi

		sleep 2
		shift
	done
	
	### debug statements ###
	#local usrin
	#chvt 8 
	#exec < /dev/tty8 > /dev/tty8 2> /dev/tty8
	#read -t 99999 -p "Completed mk_disk_labels( ), press Enter to continue" usrin
	
	#return 0
} 

function detect_mdraid {
	local MDADMCFG='/etc/mdadm.conf'
	echo '# mdadm.conf generated by rsa appliance upgrade' > $MDADMCFG
	echo 'MAILADDR root' >> $MDADMCFG 
	echo 'AUTO +0.90 +1.x +imsm -all' >> $MDADMCFG
	local blockdev=( `ls /sys/block | grep '[hs]d[a-z]'` )
	local numpart
	local count
	local part
	local mdnumdev
	local mduuid
	local mddev
	local mdlevel
	local mdstats
	local stat
	
	for device in ${blockdev[@]}
	do 
		if [[ `parted -s /dev/$device print | grep 'raid'` ]]; then 
			# get number of parttions
			let numpart=`ls /sys/block/$device | grep "$device[1-9]" | wc -l`
			# partitions start at one
			let count=1
			while [ $count -le $numpart ]
			do
				part=`parted -s /dev/$device print | grep -E -i -A$numpart '^[[:space:]]*Number[[:space:]]+Start[[:space:]]+End[[:space:]]+Size[[:space:]]+Type[[:space:]]+File[[:space:]]+system[[:space:]]+Flags' |  grep -E "^[[:space:]]*$count"` 
				if [[ `echo $part | grep 'raid'` ]]; then
					mdstats=( `mdadm --examine --scan /dev/$device$count` )
					for stat in ${mdstats[@]}
					do
						if [[ `echo $stat | grep '/dev/md/*[0-9]'` ]]; then
							# get md device
							mddev=$stat
						elif [[ `echo $stat | grep -i 'UUID'` ]]; then
							# get RAID UUID
							mduuid=$stat
						fi
					done
					# get number of devices
					mdnumdev=`mdadm -E /dev/$device$count | grep -E 'Raid[[:space:]]*Devices' | awk '{print $4}'`
					# get raid level		
					mdlevel=`mdadm -E /dev/$device$count | grep -E 'Raid[[:space:]]*Level' | awk '{print $4}'`
					# create mdadm conf file
					if ! [[ `grep -E "^[[:space:]]*ARRAY[[:space:]]+$mddev[[:space:]]+level=$mdlevel[[:space:]]+num-devices=$mdnumdev[[:space:]]+$mduuid" $MDADMCFG` ]]; then
						echo "ARRAY $mddev level=$mdlevel num-devices=$mdnumdev $mduuid" >> $MDADMCFG
						# activate device
						#mdadm -A -U super-minor -f -c /tmp/mdadm.conf $mddev
						mdadm -A -f -c /etc/mdadm.conf $mddev
					fi
				fi
				let count=$count+1
			done
		
		fi 
	done
	# copy mdadm.conf to tmp for installation/backup
	cp $MDADMCFG /tmp/
}

function backupprompt { 
	echo
	echo
	echo "------------------------------------------"
	if [ -z $1 ]; then 
		echo " ** Failed Backup ** of /tmp/nw.tbz and"
		echo " /tmp/fstab.bak. Please backup manually"
	else
		echo " ** Failed Backup ** of $1"
		echo " Please backup filei(s) manually"
	fi
	echo " to removeable media or network share"
	echo " before proceeding with system upgrade"
	echo " Without these files any upgrade errors"
	echo " will be unrecoverable possibly requiring"
	echo " a re-install of the system and data loss"
	echo " Please enter C to continue or Q to quit"
	echo "------------------------------------------"
}

function set_nwapptype {
	# determine appliance type from kickstart %packages section
	# package names prepended with a dash '-', eg: -rsa-saw-server, are assumed to be either installed
	# in %post or not installed at all
	# current defined appliance types, global variable string value
	# nwbroker, broker 
	# nwconcentrator, concentrator
	# nwdecoder, decoder
	# nwlogdecoder, logdecoder
	# spectrum enterprise, spectrumbroker
	# security analytics and broker and re, sabroker
	# logs hybrid, loghybrid
	# packet hybrid, packethybrid
	# logs aio, logaio
	# packet aio, packetaio
	# remote logcollector, logcollector
	# remote ipdb extractor, ipdbextractor
	# warehouse powered by mapR, maprwh
	# nwarchiver, archiver
	# nwwarehouseconnector, connector
	# event stream analytics, esa
#	local packstart=
#	local packend=
#	local numlines=
#	packstart=`grep -n '%packages' /run/install/ks.cfg`
#	packstart=${packstart%%:*}
#	packend=`grep -E -n '^[[:space:]]*%include[[:space:]]+/tmp/nwpack.txt' /run/install//ks.cfg`
#	packend=${packend%%:*}
#	numlines=`expr $packend - $packstart`
#	echo "numlines in %packages = $numlines" >> /tmp/pre.log	
#	if [[ `grep -A$numlines '%packages' /run/install/ks.cfg | grep -E '^[[:space:]]*\@rsa-sa-broker[[:space:]]*$'` ]]; then
#		nwapptype='broker'
#	elif [[ `grep -A$numlines '%packages' /run/install/ks.cfg | grep -E '^[[:space:]]*\@rsa-sa-concentrator[[:space:]]*$'` ]]; then
#		nwapptype='concentrator'
#	elif [[ `grep -A$numlines '%packages' /run/install/ks.cfg | grep -E '^[[:space:]]*\@rsa-sa-packet-decoder[[:space:]]*$'` ]]; then
#		nwapptype='decoder'
#	elif [[ `grep -A$numlines '%packages' /run/install/ks.cfg | grep -E '^[[:space:]]*\@rsa-sa-log-decoder[[:space:]]*$'` ]]; then
#		nwapptype='logdecoder'
#	elif [[ `grep -A$numlines '%packages' /run/install/ks.cfg | grep -E '^[[:space:]]*\@rsa-sa-packet-hybrid[[:space:]]*$'` ]]; then
#		nwapptype='packethybrid'
#	elif [[ `grep -A$numlines '%packages' /run/install/ks.cfg | grep -E '^[[:space:]]*\@rsa-sa-log-hybrid[[:space:]]*$'` ]]; then
#		nwapptype='loghybrid'
#	elif [[ `grep -A$numlines '%packages' /run/install/ks.cfg | grep -E '^[[:space:]]*\@rsa-sa-malware-analysis[[:space:]]*$'` ]]; then
#		nwapptype='spectrumbroker'
#	elif [[ `grep -A$numlines '%packages' /run/install/ks.cfg | grep -E '^[[:space:]]*\@rsa-sa-server[[:space:]]*$'` ]]; then
#		nwapptype='sabroker'
#	elif [[ `grep -A$numlines '%packages' /run/install/ks.cfg | grep -E '^[[:space:]]*\@rsa-sa-log-aio[[:space:]]*$'` ]]; then
#		nwapptype='logaio'
#	elif [[ `grep -A$numlines '%packages' /run/install/ks.cfg | grep -E '^[[:space:]]*\@rsa-sa-packet-aio[[:space:]]*$'` ]]; then
#		nwapptype='packetaio'
#	elif [[ `grep -A$numlines '%packages' /run/install/ks.cfg | grep -E '^[[:space:]]*-\@rsa-sa-remote-logcollector[[:space:]]*$'` ]] && ! [[ `grep -A$numlines '%packages' /run/install/ks.cfg | grep -E '^[[:space:]]*\@rsa-sa-log-decoder[[:space:]]*$'` ]] && ! [[ `grep -A$numlines '%packages' /run/install/ks.cfg | grep -E '^[[:space:]]*\@rsa-sa-log-aio[[:space:]]*$'` ]] && ! [[ `grep -A$numlines '%packages' /run/install/ks.cfg | grep -E '^[[:space:]]*\@rsa-sa-log-hybrid[[:space:]]*$'` ]]; then
#		nwapptype='logcollector'
#	elif [[ `grep -A$numlines '%packages' /run/install/ks.cfg | grep -E '^[[:space:]]*\@rsa-sa-remote-ipdbextractor[[:space:]]*$'` ]]; then
#		nwapptype='ipdbextractor' 
#	elif [[ `grep -A$numlines '%packages' /run/install/ks.cfg | grep -E '^[[:space:]]*-rsa-saw-server[[:space:]]*$'` ]]; then
#		nwapptype='maprwh'
#	elif [[ `grep -A$numlines '%packages' /run/install/ks.cfg | grep -E '^[[:space:]]*\@rsa-sa-archiver[[:space:]]*$'` ]]; then
#		nwapptype='archiver'
#	elif [[ `grep -A$numlines '%packages' /run/install/ks.cfg | grep -E '^[[:space:]]*-\@rsa-sa-warehouse-connector[[:space:]]*$'` ]] && ! [[ `grep -A$numlines '%packages' /run/install/ks.cfg | grep -E '^[[:space:]]*\@rsa-sa-log-decoder[[:space:]]*$'` ]] && ! [[ `grep -A$numlines '%packages' /run/install/ks.cfg | grep -E '^[[:space:]]*\@rsa-sa-log-hybrid[[:space:]]*$'` ]] && ! [[ `grep -A$numlines '%packages' /run/install/ks.cfg | grep -E '^[[:space:]]*\@rsa-sa-packet-decoder[[:space:]]*$'` ]] && ! [[ `grep -A$numlines '%packages' /run/install/ks.cfg | grep -E '^[[:space:]]*\@rsa-sa-packet-hybrid[[:space:]]*$'` ]]; then
#		nwapptype='connector'
#	elif [[ `grep -A$numlines '%packages' /run/install/ks.cfg | grep -E '^[[:space:]]*\@rsa-sa-esa-server[[:space:]]*$'` ]]; then
#		nwapptype='esa'
#	fi
#
	nwapptype='bootstrap'	
	if [ $nwapptype ]; then
		#echo "nwapptype = $nwapptype" > /dev/tty2
		echo "$nwapptype" > /tmp/nwapptype
		echo "nwapptype = $nwapptype" >> /tmp/pre.log
	fi
}

function set_nwsystem {
	# check supported hardware
	local my_board=`dmidecode -t 2 | grep -i 'Product Name:' | awk '{print $3}'`
	local my_system=`dmidecode -t 1 | grep -i 'Product Name:' | awk '{print $4}'`
	local my_manufacturer=`dmidecode -t 1 | grep -i 'Manufacturer:' | awk '{print $2}'`
	local my_id=
	echo "my_board = $my_board" >> /tmp/pre.log
	echo "my_manufacturer = $my_manufacturer" >> /tmp/pre.log
	echo "my_system = $my_system" >> /tmp/pre.log

### EOL Hardware ###
#	if [[ `echo "$my_manufacturer" | grep -i 'Supermicro'` ]]; then
#		case "$my_board" in
#			"X8DTN+-F" )
#				# sm (nehalem cpu) 1200n/2400n series concentrator, decoder and spectrum
#				nwsystem='sm-s3-2u'
#			;;
#			"X7DWN+" )
#				# sm 1200/2400 series decoder and concentrator
#				nwsystem='sm-s2-2u'
#			;;
#			# eagle no longer supported for NG 10.x
#			#"X7SB4/E" )
#			#	nwsystem='sm-eagle'
#			#;;
#			"X8SIU" )
#				# sm 200 series broker
#				nwsystem='sm-s3-1u-brok'
#			;;
#			"X8DTU-6+" )
#				# sm 200 series hybrid and spectrum
#				nwsystem='sm-s3-1u'
#			;;
#			"X7SBi" )
#				# sm 100 series broker and decoder
#				nwsystem='sm-s2-1u'
#			;;
#			"X7DBU" )
#				# sm 100 series concentrator
#				nwsystem='sm-s2-1u-conc'
#			;;
#		esac
#	elif [[ `echo "$my_manufacturer" | grep -i 'Intel'` ]]; then
#		case "$my_board" in
#			"S2600GZ" )
#				nwsystem='grizzlypass'
#			;;
#			"S5000PSL" )
#				nwsystem='mckaycreek'
#			;;
#		esac
### End EOL Hardware ###
	if [[ `echo "$my_manufacturer" | grep -i 'Dell'` ]] || ! [ $my_manufacturer ]; then
		# white box system, attempt to get product ID
		if ! [ $my_manufacturer ]; then
			my_id=`dmidecode -t 11 | grep -i 'String 5' | awk -F[ '{print $2}' | awk '{print $1}'`
		        my_id=${my_id%]}
			if ! [[ `echo ${my_id} | grep -E '[0-9]+'` ]]; then
				my_id=`dmidecode -t 11 | grep -i 'String 4' | awk -F[ '{print $2}' | awk '{print $1}'`
			        my_id=${my_id%]}
			fi
		fi
### EOL Hardware ### 
#		if [[ `echo "$my_board" | grep -E '0P229K|05XKKK'` ]] || [[ "$my_system" == "R310" ]]; then
#			nwsystem='dell-s3-1u-brok'
#		elif [[ "$my_board" = "0N83VF" || "$my_system" = "R410" ]]; then
#			nwsystem='dell-s3-1u'
#		elif [[ `echo "$my_board" | grep -E '00HDP0|0DPRKF'` ]] || [[ "$my_system" == "R510" ]]; then
#			nwsystem='dell-s3-2u'
### End EOL Hardware ###
		if [[ "$my_board" = "0P8FRD" || "$my_system" = "R610" ]]; then
			nwsystem='dell-s4-1u'
		elif [[ "$my_board" = "0XDX06" || "$my_system" = "R710" ]]; then
			nwsystem='dell-s4-2u'
		elif [[ "$my_board" = "0KFFK8" || "$my_board" == "036FVD" || "$my_system" = "R620" ]] || [ "$my_id" = '8122' ]; then
			nwsystem='dell-s4s-1u'
		elif [[ "$my_board" = "086D43" || "$my_system" = "R630" ]] || [ "$my_id" = '8134' ]; then
			nwsystem='dell-s9-1u'
		elif [[ "$my_board" = "04N3DF" || "$my_system" = "R730" ]] || [ "$my_id" = '8149' ]; then
			nwsystem='dell-s5-2u'
		fi
	fi
	
	# everthing else is considered either vmware or third party including unsupported hardware
	if ! [ ${nwsystem} ]; then
		if [[ `echo "$my_manufacturer" | grep -i 'VMware'` ]]; then
			nwsystem='vmware'
		else
			nwsystem='thirdparty'
		fi
	fi

	echo "$nwsystem" > /tmp/nwsystem
	echo "nwsystem = $nwsystem" >> /tmp/pre.log
}

function verify_upgrade_path {
	# rename install image's rpm database, no installer kernel support for rpm --dbpath switch 
	echo "re-naming installer rpm database" >> /tmp/pre.log
	mv -f  /var/lib/rpm /var/lib/oldrpm
	sleep 2	
	# mount existing var or root volumes and link rpm database path to install image
	if [[ `grep -E '[[:space:]]/var[[:space:]]' /tmp/cfgbak/fstab` ]]; then
		local varvol=`grep -E '[[:space:]]/var[[:space:]]' /tmp/cfgbak/fstab | awk '{print $1}'`
		echo "mounting '/var' lv $varvol for rpm package check" >> /tmp/pre.log
		mount $varvol /tmp/mnt
		sleep 2 
		echo "linking existing rpm database to installer" >> /tmp/pre.log
		ln -s -t /var/lib /tmp/mnt/lib/rpm
		sleep 2
		# remove any stale locks	
		echo "removing any stale locks from existing rpm database" >> /tmp/pre.log
		rm -f /var/lib/rpm/__db.*
		# archive rpm db
		echo 'backing up existing rpm database: /tmp/cfgbak/rpm.tbz' | tee -a /tmp/pre.log
		tar -C /tmp/mnt/lib -cjf /tmp/cfgbak/rpm.tbz rpm/
	else
		echo "mounting '/' root lv /dev/VolGroup00/root for rpm package check" >> /tmp/pre.log
		mount /dev/VolGroup00/root /tmp/mnt
		sleep 2
		echo "linking existing rpm database to installer" >> /tmp/pre.log
		ln -s -t /var/lib /tmp/mnt/var/lib/rpm
		sleep 2
		# remove any stale locks	
		echo "removing any stale locks from existing rpm database" >> /tmp/pre.log
		rm -f /var/lib/rpm/__db.*
		# archive rpm db
		echo 'backing up existing rpm database: /tmp/cfgbak/rpm.tbz' | tee -a /tmp/pre.log
		tar -C /tmp/mnt/var/lib -cjf /tmp/cfgbak/rpm.tbz rpm/
	fi

	# check for logcollector installation
	if [[ `rpm -q nwlogcollector | grep -E 'nwlogcollector-[0-9]+\.[0-9]+'` ]]; then
		logcoll=true
	fi
	
	# check for warehouse connector installation
	if [[ `rpm -q nwwarehouseconnector | grep -E 'nwwarehouseconnector-[0-9]+\.[0-9]+'` ]]; then
		warehouseconn=true
	fi

	# validate installed system against menu item selected
	local errcode=
	local errstr=
	case $nwapptype in
		archiver )
			if [[ `rpm -q nwarchiver | grep -E 'nwarchiver-[0-9]+\.[0-9]+'` ]]; then
				errcode=0
			else
				errcode=1
				errstr='missing application(s) detected'
			fi
		;;
		broker )
			if [[ `rpm -q nwbroker | grep -E 'nwbroker-[0-9]+\.[0-9]+'` ]] && ! [[ `rpm -q security-analytics-web-server | grep -E 'security-analytics-web-server-[0-9]+\.[0-9]+'` || `rpm -q sa-server | grep -E 'sa-server-[0-9]+\.[0-9]+'` || `rpm -q sa | grep -E 'sa-[0-9]+\.[0-9]+'` ]] && ! [[ `rpm -q rsaMalwareDeivce | grep -E 'rsaMalwareDevice-[0-9]+\.[0-9]+'` ]]; then
				errcode=0
			else
				errcode=1
				errstr='missing or additional application(s) detected'
			fi
		;;
		concentrator )
			if  [[ `rpm -q nwconcentrator | grep -E 'nwconcentrator-[0-9]+\.[0-9]+'` ]] && ! [[ `rpm -q nwdecoder | grep -E 'nwdecoder-[0-9]+\.[0-9]+'` ]] && ! [[ `rpm -q nwlogdecoder | grep -E 'nwlogdecoder-[0-9]+\.[0-9]+'` ]]; then
				errcode=0
			else
				errcode=1
				errstr='missing or additional application(s) detected'
			fi
		;;
		# stand alone warehouse connector not currently released
		#connector )
		#;;
		decoder )
			if  [[ `rpm -q nwdecoder | grep -E 'nwdecoder-[0-9]+\.[0-9]+'` ]] && ! [[ `rpm -q nwconcentrator | grep -E 'nwconcentrator-[0-9]+\.[0-9]+'` ]]; then
				errcode=0
			else
				errcode=1
				errstr='missing or additional application(s) detected'
			fi
		;;
		esa )
			if [[ `rpm -q rsa-esa-server | grep -E 'rsa-esa-server-[0-9]+\.[0-9]+'` ]]; then
				errcode=0
			else
				errcode=1
				errstr='missing application(s) detected'
			fi
		;;
		ipdbextractor )
			if [[ `rpm -q nwipdbextractor | grep -E 'nwipdbextractor-[0-9]+\.[0-9]+'` ]] && ! [[ `rpm -q re-server | grep -E 're-server-[0-9]+\.[0-9]+'` ]]; then
				errcode=0
			else
				errcode=1
				errstr='missing or additional application(s) detected'
			fi
		;;
		logaio )
			if [[ `rpm -q nwlogdecoder | grep -E 'nwlogdecoder-[0-9]+\.[0-9]+'` && `rpm -q nwlogcollector | grep -E 'nwlogcollector-[0-9]+\.[0-9]+'` && `rpm -q nwconcentrator | grep -E 'nwconcentrator-[0-9]+\.[0-9]+'` ]] && [[ `rpm -q nwbroker | grep -E 'nwbroker-[0-9]+\.[0-9]+'` ]] && [[ `rpm -q security-analytics-web-server | grep -E 'security-analytics-web-server-[0-9]+\.[0-9]+'` || `rpm -q sa-server | grep -E 'sa-server-[0-9]+\.[0-9]+'` || `rpm -q sa | grep -E 'sa-[0-9]+\.[0-9]+'` ]]; then
				errcode=0
			else
				errcode=1
				errstr='missing application(s) detected'
			fi
		;;
		logcollector )
			if [[ `rpm -q nwlogcollector | grep -E 'nwlogcollector-[0-9]+\.[0-9]+'` ]] && ! [[ `rpm -q nwlogdecoder | grep -E 'nwlogdecoder-[0-9]+\.[0-9]+'` ]]; then
				errcode=0
			else
				errcode=1
				errstr='missing or additional application(s) detected'
			fi
		;;
		logdecoder )
			if [[ `rpm -q nwlogdecoder | grep -E 'nwlogdecoder-[0-9]+\.[0-9]+'` ]] && ! [[ `rpm -q nwconcentrator | grep -E 'nwconcentrator-[0-9]+\.[0-9]'` ]]; then
				errcode=0
			else
				errcode=1
				errstr='missing or additional application(s) detected'
			fi
		;;
		loghybrid )
			if [[ `rpm -q nwlogdecoder | grep -E 'nwlogdecoder-[0-9]+\.[0-9]+'` && `rpm -q nwlogcollector | grep -E 'nwlogcollector-[0-9]+\.[0-9]+'` && `rpm -q nwconcentrator | grep -E 'nwconcentrator-[0-9]+\.[0-9]+'` ]] && ! [[ `rpm -q nwbroker | grep -E 'nwbroker-[0-9]+\.[0-9]+'` ]] && ! [[ `rpm -q security-analytics-web-server | grep -E 'security-analytics-web-server-[0-9]+\.[0-9]+'` || `rpm -q sa-server | grep -E 'sa-server-[0-9]+\.[0-9]+'` || `rpm -q sa | grep -E 'sa-[0-9]+\.[0-9]+'` ]]; then
				errcode=0
			else
				errcode=1
				errstr='missing or additional application(s) detected'
			fi
		;;
		packetaio )
			if [[ `rpm -q nwdecoder | grep -E 'nwdecoder-[0-9]+\.[0-9]+'` && `rpm -q nwconcentrator | grep -E 'nwconcentrator-[0-9]+\.[0-9]+'` && `rpm -q nwbroker | grep -E 'nwbroker-[0-9]+\.[0-9]+'` ]] && [[ `rpm -q security-analytics-web-server | grep -E 'security-analytics-web-server-[0-9]+\.[0-9]+'` || `rpm -q sa-server | grep -E 'sa-server-[0-9]+\.[0-9]+'` || `rpm -q sa | grep -E 'sa-[0-9]+\.[0-9]+'` ]]; then
				errcode=0
			else
				errcode=1
				errstr='missing application(s) detected'
			fi
		;;
		packethybrid )
			if [[ `rpm -q nwdecoder | grep -E 'nwdecoder-[0-9]+\.[0-9]+'` && `rpm -q nwconcentrator | grep -E 'nwconcentrator-[0-9]+\.[0-9]+'` ]] && ! [[ `rpm -q nwbroker | grep -E 'nwbroker-[0-9]+\.[0-9]+'` ]] && ! [[ `rpm -q security-analytics-web-server | grep -E 'security-analytics-web-server-[0-9]+\.[0-9]+'` || `rpm -q sa-server | grep -E 'sa-server-[0-9]+\.[0-9]+'` || `rpm -q sa | grep -E 'sa-[0-9]+\.[0-9]+'` ]]; then
				errcode=0
			else
				errcode=1
				errstr='missing or additional application(s) detected'
			fi
		;;
		sabroker )
			if [[ `rpm -q nwbroker | grep -E 'nwbroker-[0-9]+\.[0-9]+'` ]] && [[ `rpm -q security-analytics-web-server | grep -E 'security-analytics-web-server-[0-9]+\.[0-9]+'` || `rpm -q sa-server | grep -E 'sa-server-[0-9]+\.[0-9]+'` || `rpm -q sa | grep -E 'sa-[0-9]+\.[0-9]+'` ]] && ! [[ `rpm -q nwconcentrator | grep -E 'nwconcentrator-[0-9]+\.[0-9]+'` ]]; then
				errcode=0
			else
				errcode=1
				errstr='missing or additional application(s) detected'
			fi
		;;
		maprwh )
			if [[ `rpm -q mapr-core | grep -E 'mapr-core-[0-9]+\.[0-9]+'` ]]; then
				errcode=0
			else
				errcode=1
				errstr='missing application(s) detected'
			fi
		;;
		spectrumbroker )
			if [[ `rpm -q nwbroker | grep -E 'nwbroker-[0-9]+\.[0-9]+'` ]] && [[ `rpm -q rsaMalwareDeivce | grep -E 'rsaMalwareDevice-[0-9]+\.[0-9]+'` ]]; then
				errcode=0
			elif [[ `rpm -q nwspectrum-server | grep -E 'nwspectrum-server-[0-9]+\.[0-9]+'` ]]; then
				errcode=1
				errstr='upgrade of spectrum appliances not supported'
			else
				errcode=1
				errstr='missing application(s) detected'
			fi
		;;
		spectrumdecoder )
			errcode=1
			errstr='malware prevention stand alone not supported'
		;; 
	esac
	
	# debug statement
	#echo "sleeping"
	#sleep 99999
	
	# restore image's rpm database 
	echo "restoring installer rpm database" >> /tmp/pre.log
	umount /tmp/mnt
	sleep 3
	rm -f /var/lib/rpm
	mv -f /var/lib/oldrpm /var/lib/rpm
	if ! [ $errcode = 0 ]; then
		chvt 8 
		echo
		echo
		echo '-----------------------------------------------------'
		echo " Upgrade of $nwapptype has failed validation testing"
		echo " Reason: $errstr"
		echo ' Please verify menu selection, restart in 2 minutes'
		echo ' <CTRL><ALT><DEL> to restart now'
		echo '-----------------------------------------------------'
		# debug statement	
		#sleep 99999 
		return 1
	else
		# debug statement
		#sleep 99999 
		return 0
	fi
}

function writeRaidScript {
	local volumeCommands="$1"
	local bootVol="$2"
	local SCRIPT=/tmp/initraid.sh
	
	echo "writing configure raid script: $SCRIPT" >> /tmp/pre.log
	echo "\$bootVol = $bootVol" >> /tmp/pre.log

	echo "#!/bin/bash
COMMAND_TOOL=${COMMAND_TOOL}" > $SCRIPT

	# msdos partition <= 2.2 TiB
	if [[ `echo "$bootVol" | grep -i 'msdos'` || -z $2 ]]; then
		echo 'NEW_LD_OPTIONS="WB RA Cached CachedBadBBU -strpsz128"' | tee -a /tmp/pre.log >> $SCRIPT
	# gpt partition > 2.2 TiB, create separate boot volume
	elif [[ `echo "$bootVol" | grep -i 'gpt'` ]]; then 
		echo 'NEW_LD_OPTIONS_1="WB RA Cached CachedBadBBU -sz163840 -strpsz128"' | tee -a /tmp/pre.log >> $SCRIPT
		echo 'NEW_LD_OPTIONS_2="WB RA Cached CachedBadBBU -strpsz128"' >> $SCRIPT
	else
		echo "error return 1, invalid parameter in writeRaidScript(): \$2 = $2" >> /tmp/pre.log
		return 1
	fi
	
	echo "\$volumeCommands = $volumeCommands" >> /tmp/pre.log 
	echo '
# if specified, set adapter ID
if [ -e /tmp/intAdapterId ]; then
	adpID=`cat /tmp/intAdapterId`' >> $SCRIPT
	echo '	ENCID=$("$COMMAND_TOOL" -pdlist -a$adpID | while read p1 p2 p3 p4; do if [ "$p1" == "Enclosure" ]; then echo $p4; break; fi; done)' >> $SCRIPT
	echo '	ADAPTER=$adpID
else' >> $SCRIPT
	echo '	ENCID=$("$COMMAND_TOOL" -pdlist -a0 | while read p1 p2 p3 p4; do if [ "$p1" == "Enclosure" ]; then echo $p4; break; fi; done)' >> $SCRIPT

	echo '	ADAPTER=0
fi
' >> $SCRIPT
	
	echo "	$volumeCommands" >> $SCRIPT
	
	
	echo '	# take a moment to be sure the new volumes show up.		
	sleep 8
	exit 0
fi
' >> $SCRIPT
	chmod u+x $SCRIPT
return 0
}

function invalid_hw {
	echo
	echo
	echo "---------------------------------------------"
	echo " Unable to determine system hardware version"
	echo " or non supported system hardware detected"
	echo " No installation/upgrade method is available"
	echo " Installation cannot continue"
	echo "---------------------------------------------"
	echo
	promptReboot
}

function set_raid_packs_post {
	local volumesetup
	
	# determine install type
	if ! [ $installtype ]; then
		set_installtype
	fi

	# if two hard drive tests are required for hw raid appliance, assign raid check to $drivetest2
	case $nwapptype in
		bootstrap )
			case $nwsystem in
				# 4 series bootstrap
				dell-s4-1u )
					hwraid=True
					drivetest="check_enc_drive_sizes 160 160 1000 1000"
					#drivetest=check_nwx_drives
					drivetest2=check_dell_bootstrap_mirrors
					volumesetup='# system volume group is 2 HW RAID1 mirrors
"$COMMAND_TOOL" -cfgldadd -R1[$ENCID:0,$ENCID:1] $NEW_LD_OPTIONS -a$ADAPTER
"$COMMAND_TOOL" -cfgldadd -R1[$ENCID:2,$ENCID:3] $NEW_LD_OPTIONS -a$ADAPTER'
					writeRaidScript "$volumesetup" msdos
				;;
				# 4s series bootstrap
				dell-s4s-1u )
					if check_for_newport_drives
					then	
						inewport=True
						echo "inewport = ${inewport}" | tee -a /tmp/pre.log > /dev/tty8
						hwraid=True
						drivetest=check_dell_bootstrap_mirrors
						volumesetup='# system volume is 2 drives in RAID 1 mode
"$COMMAND_TOOL" -cfgldadd -R1[$ENCID:0,$ENCID:1] $NEW_LD_OPTIONS -a$ADAPTER'					
						writeRaidScript "$volumesetup" msdos 
					else 
						echo "inewport = ${inewport}" | tee -a /tmp/pre.log > /dev/tty8
						hwraid=True
						drivetest="check_enc_drive_sizes 147 147 1000 1000"
						drivetest2=check_dell_bootstrap_mirrors
						volumesetup='# system volume group is 2 HW RAID1 mirrors
"$COMMAND_TOOL" -cfgldadd -R1[$ENCID:0,$ENCID:1] $NEW_LD_OPTIONS -a$ADAPTER
"$COMMAND_TOOL" -cfgldadd -R1[$ENCID:2,$ENCID:3] $NEW_LD_OPTIONS -a$ADAPTER'
						writeRaidScript "$volumesetup" msdos
					fi
				;;
				# 9 series bootstrap
				dell-s9-1u )
					if check_for_s7_drives
					then
						iseries7=True
						hwraid=True
						drivetest=check_esa_raid
						volumesetup=volumesetup='# system volume is 1 HW RAID1 and 1 3@HDD HW RAID5
"$COMMAND_TOOL" -cfgldadd -R1[$ENCID:0,$ENCID:1] $NEW_LD_OPTIONS -a$ADAPTER
"$COMMAND_TOOL" -cfgldadd -R5[$ENCID:2,$ENCID:3,$ENCID:4] $NEW_LD_OPTIONS -a$ADAPTER
"$COMMAND_TOOL" -PDHSP -Set -Dedicated -Array1 -PhysDrv[$ENCID:5] -a$ADAPTER' 
						writeRaidScript "$volumesetup" msdos
					else
						hwraid=True
						drivetest="check_enc_drive_sizes 1000 1000 2000 2000"
						drivetest2=check_dell_bootstrap_mirrors
						volumesetup='# system volume group is 2 HW RAID1 mirrors
"$COMMAND_TOOL" -cfgldadd -R1[$ENCID:0,$ENCID:1] $NEW_LD_OPTIONS -a$ADAPTER
"$COMMAND_TOOL" -cfgldadd -R1[$ENCID:2,$ENCID:3] $NEW_LD_OPTIONS -a$ADAPTER'
						writeRaidScript "$volumesetup" msdos
					fi
				;;
				# series 5 2U hybrid
				dell-s5-2u )
					hwraid=True
					drivetest=check_dell_bootstrap_mirrors
					volumesetup='# system volume group is 2 HW RAID1 mirrors
"$COMMAND_TOOL" -cfgldadd -R1[$ENCID:0,$ENCID:1] $NEW_LD_OPTIONS -a$ADAPTER
"$COMMAND_TOOL" -cfgldadd -R1[$ENCID:2,$ENCID:3] $NEW_LD_OPTIONS -a$ADAPTER'
					writeRaidScript "$volumesetup" msdos
				;;
#				# un-qualified hardware
#				* )
#					invalid_hw
#				;;	
			esac
			#echo '%end' >> /tmp/nwpack.txt
		;;
	esac
}

function set_installtype {
	# determine install method
	if [[ `dmesg | grep -i 'kernel command line' | grep 'ks=hd'` ]]; then
		installtype='usb'
		echo "installtype = usb" >> /tmp/pre.log
	else
		echo "installtype = cdrom/url" >> /tmp/pre.log
	fi
}

function usenwhome {
	# delete, re-create netwitness volume for config backup, ultimately resize and grow filesystem in %post

	# as netwitness home, i.e. /var/netwitness, volume sizes have changed over time
	# remove netwitness volume and recreate 4GB volume	
	if [[ `ls /dev/mapper/VolGroup00-home` ]]; then
		echo "deleting logical volume: /dev/VolGroup00/home" | tee -a /tmp/pre.log
		lvremove -f /dev/VolGroup00/home
	elif [[ `ls /dev/mapper/VolGroup00-nwhome` ]]; then
		echo "deleting logical volume: /dev/VolGroup00/nwhome" | tee -a /tmp/pre.log
		lvremove -f /dev/VolGroup00/nwhome
	fi
	lvcreate -n nwhome -L 4096M /dev/VolGroup00
	lvchange -ay /dev/VolGroup00/nwhome
	mkfs.xfs /dev/VolGroup00/nwhome
	echo 'true' > /tmp/baknwhome 
}

function detect_install_devices {
# create list of valid install block devices, filtering DRAC virtual devices
	unset installdev
	unset installmodel
	local count
	local item
	local i
	local blockdev=( `ls /sys/block | grep 'sd[a-z]'` )
	let count=0
	for item in ${blockdev[@]}
	do
		# check for planar block devices, i.e. not on raid bus
		if [[ `grep -i 'ATA' /sys/block/$item/device/vendor` ]]; then
			installdev[$count]=$item
			installmodel[$count]=`cat /sys/block/$item/device/model`
			atablkdev=$count
			let count=$count+1
		fi
		cat /sys/block/$item/device/model > /tmp/out.txt
		#echo "item = $item"
		for i in "${raid_models_list[@]}"
		do
			if [[ `grep -is "$i" /tmp/out.txt` ]]; then
				installdev[$count]=$item
				installmodel[$count]=`cat /sys/block/$item/device/model`
				let count=$count+1
			fi
		done
	done
}

function upgrade_recovery {
# attempt to restore system back to a upgradeable, not running,  state
	mkdir -p /tmp/mnt
	mount -t ext4 /dev/mapper/VolGroup00-rsaupgdtry /tmp/mnt
	local rootfsuuid=`cat /tmp/mnt/rootfsuuid.txt`
	local bkuproot=`cat /tmp/mnt/bkuproot.txt`
	umount /tmp/mnt
	mount $bkuproot /tmp/mnt
	rm -Rf /dev/cfgbak/
	cp -Rp /tmp/mnt/cfgbak/ /dev/
	umount /tmp/mnt
	if ! [[ `ls /dev/VolGroup00 | grep -i '^root'` ]]; then
		lvcreate -n root -L 10240M /dev/mapper/VolGroup00
		lvchange -ay /dev/mapper/VolGroup00-root
	fi
	mkfs.ext4 -F /dev/mapper/VolGroup00-root
	tune2fs -U $rootfsuuid /dev/mapper/VolGroup00-root
	if ! [[ `ls /dev/VolGroup00 | grep -i '^var'` ]]; then
		lvcreate -n var -L 4096M /dev/mapper/VolGroup00
		lvchange -ay /dev/mapper/VolGroup00-var
	fi
	mkfs.ext4 -F /dev/mapper/VolGroup00-var
	mount /dev/mapper/VolGroup00-var /tmp/mnt
	mkdir -p /tmp/mnt/lib
	tar -C /tmp/mnt/lib -xjf /tmp/cfgbak/rpm.tbz
	umount /tmp/mnt
	mount /dev/mapper/VolGroup00-root /tmp/mnt
	mkdir -p /tmp/mnt/etc/sysconfig/network-scripts /tmp/mnt/etc/lvm /tmp/mnt/root
	cp -p /tmp/cfgbak/fstab /tmp/mnt/etc/
	cp -p /tmp/cfgbak/passwd /tmp/mnt/etc/
	cp -p /tmp/cfgbak/shadow /tmp/mnt/etc/
	cp -p /tmp/cfgbak/group /tmp/mnt/etc/
	if [ -s /tmp/cfgbak/mdadm.conf ]; then
		cp -p /tmp/cfgbak/mdadm.conf /tmp/mnt/etc/
	fi
	cp -p /tmp/cfgbak/lvm.conf /tmp/mnt/etc/lvm/
	cp -p /tmp/cfgbak/hosts /tmp/mnt/etc/ 
	cp -p /tmp/cfgbak/resolv.conf /tmp/mnt/etc/
	cp -p /tmp/cfgbak/network /tmp/mnt/etc/sysconfig/
	cp -p /tmp/cfgbak/ifcfg-* /tmp/mnt/etc/sysconfig/network-scripts/
	if [ -d /tmp/cfgbak/.ssh ]; then
		cp -Rp /tmp/cfgbak/.ssh /tmp/mnt/root/
	fi	
	tar -C /tmp/mnt/etc -xjf /tmp/cfgbak/nw.tbz
	umount /tmp/mnt
}

function check_upgrade { 
	local SYSPARTS='/tmp/nwpart.txt'
	local APPMNTS='/tmp/nwvols.txt' 
	local errcode
	local baknwhome
	local usrChoice=q
	local mntfail
	local exitcode
	local vgfreemb
	local item
	local i
	local rootlv
	local rootfsuuid
	local size
	local count
	local varlv
	local nwlv
	local warecbkup
	# presence of rsa home logical volume, i.e. /opt/rsa, not in volume group "VolGroup00"
	local rabmqvol
	local vg00lv
	
#	if ! [ $nwapptype ]; then
#		set_nwapptype
#	fi
	if ! [ $nwsystem ]; then
		set_nwsystem
	fi
	
	if ! [ $installtype ]; then
		set_installtype
	fi 
	
	# copy fips compliant openssl package to /tmp
	#copy_openssl_fips
	
	chvt 8
        exec < /dev/tty8 > /dev/tty8 2> /dev/tty8
	echo
	echo
	echo "examining system storage ..."
	echo
	# activate SW RAID devices
	echo 'detecting linux raid devices'
	detect_mdraid
	
	# rescan/activate VGs', LVs' 
	echo 'performing volume group scan'
	vgscan --mknodes
	echo 'running volume group check'
	vgck -v
	echo 'activating volume groups'
	vgchange -ay --ignorelockingfailure
	sleep 10	
	
	# new in centos 6.5 /tmp is only 250MB, /dev is 48GB or 50% of RAM 
	# create a ram disk or just use /dev ?
	mkdir -p /tmp/mnt /tmp/mpoint
	mkdir -p /dev/cfgbak 
	cd /tmp 
	ln -s ../dev/cfgbak cfgbak

	if [ -d /dev/VolGroup00 ]; then
		# get listing of VolGroup00 logical volumes
		vg00lv=( `ls /dev/VolGroup00` )
	
		# check for previous upgrade attempt and prompt to continue
		for item in ${vg00lv[@]} 
		do
			if [[ `echo $item | grep 'rsaupgdtry'` ]]; then
				unset usrChoice
				echo
				echo
				echo '-----------------------------------'
				echo ' Previous upgrade attempt detected'
				echo ' Performing a subsequent upgrade'
				echo ' operation may cause loss of data'
				echo ' Please contact product support'
				echo ' before attempting another upgrade'
				echo ' ---------------------------------'
				read -t 120 -p "Enter (y/Y) to continue upgrade, defaults to Quit? " usrChoice
				if [[ $usrChoice = y || $usrChoice = Y ]]; then
					# add upgrade recovery function call here
					echo ' restoring persistent backup'x	
					upgrade_recovery
					### debug statements ###
					#echo 'sleeping indefinitely'
					#sleep 99999	
				else	
					exit 1
				fi
			fi
		done
		unset vg00lv
	fi

	# check if system could be upgraded
	if [[ -e /dev/mapper/VolGroup00-root ]]; then 
		
		mount /dev/VolGroup00/root /tmp/mnt
		
		# check OS level, only allow upgrade of CentOS 5.x appliances
		# testing el6 upgrade partitioning
		#if [[ `grep -E '[[:space:]]6\.[0-9][[:space:]]' /tmp/mnt/etc/redhat-release` ]]; then
		if ! [[ `grep -E '[[:space:]]6\.[0-9][[:space:]]' /tmp/mnt/etc/redhat-release` ]]; then
			echo
			echo -n ' Detected OS Level: '
			cat /tmp/mnt/etc/redhat-release
			echo '--------------------------------------------------'
			echo ' Same OS major version upgrades are not supported'
			echo ' For example upgrading CentOS 7.2 -> CentOS 7.3'
			echo ' If you had intended to upgrade please quit and'
			echo ' contact support, <CTRL><ALT><DEL> to restart'
			echo ' Prompting for install/reinstall in 120 seconds'
			echo '--------------------------------------------------'
			echo
			sleep 120
			make_install_parts $nwsystem
		fi
		
		if ! [ -s /tmp/mnt/etc/fstab ]; then
			echo
			echo '---------------------------------------------------'
			echo ' Unable to open existing system /etc/fstab file'
			echo ' Possible Cause: mount failure of logical volume'
			echo ' VolGroup00-root, missing/corrupted fstab file'
			echo ' Error is unrecoverable, upgrade not possible'
			echo ' If you had intended to upgrade please disconnect'
			echo ' install media, reboot and contact product support'
			echo ' Re-install or Quit, re-installs delete all data'
			echo '---------------------------------------------------'
			read -t 120 -p " Re-install?, defaults to Quit in 120 seconds R/Q? " usrChoice
			if [[ "$usrChoice" = 'q' || "$usrChoice" = 'Q' ]]; then
				exit 1
			else
				make_install_parts $nwsystem $usrChoice 
			fi
		fi
		
		# back up configuration files
		usrchoice=q
		echo 'backing up system configuration ...'
		if [ -s /tmp/mnt/etc/mdadm.conf ]; then
			echo "backing up /etc/mdadm.conf" | tee -a /tmp/pre.log
			cp /tmp/mnt/etc/mdadm.conf /tmp/cfgbak/mdadm.conf.orig
		fi
		if [ -d /tmp/mnt/root/.ssh ]; then
			echo "backing up root's .ssh/ folder" | tee -a /tmp/pre.log
			cp -Rp /tmp/mnt/root/.ssh /tmp/cfgbak/
		fi
		cp /tmp/mnt/etc/fstab /tmp/cfgbak/ &&
		sync && 
		# backup network configuration
		cp /tmp/mnt/etc/hosts /tmp/cfgbak/ &&
		cp /tmp/mnt/etc/sysconfig/network /tmp/cfgbak/ &&
		cp /tmp/mnt/etc/sysconfig/network-scripts/ifcfg-* /tmp/cfgbak/ &&
		cp /tmp/mnt/etc/resolv.conf /tmp/cfgbak/ &&
		cp /tmp/mnt/etc/passwd /tmp/cfgbak/ &&
		cp /tmp/mnt/etc/shadow /tmp/cfgbak/ &&
 		cp /tmp/mnt/etc/group /tmp/cfgbak/ &&
 		cp /tmp/mdadm.conf /tmp/cfgbak/ &&
 		cp /tmp/mnt/etc/lvm/lvm.conf /tmp/cfgbak/ &&
		rm -f /tmp/mnt/etc/sysconfig/network-scripts/ifcfg-lo ||
		{ backupprompt; read -t 120 -p " Continue?, defaults to Quit in 120 seconds C/Q? " usrChoice; if [[ "$usrChoice" = 'q' || "$usrChoice" = 'Q' ]]; then exit 1; fi }
		
		# read contents of fstab
		let count=0
		while read line
		do
			sysmounts[$count]="$line"
			let count=$count+1
		done < /tmp/mnt/etc/fstab
		
		# save nw appliance configurations
		usrChoice=q
		if [ -d /tmp/mnt/etc/netwitness ]; then
			echo "archiving /etc/netwitness ..."
			tar -cjf /tmp/cfgbak/nw.tbz -C /tmp/mnt/etc netwitness/ --exclude='index-*.xml'
			errcode=$?
			if [ "$errcode" != '0' ]; then
				backupprompt
				read -t 120 -p " Continue?, defaults to Quit in 120 seconds C/Q? " usrChoice
				if [[ "$usrChoice" = 'q' || "$usrChoice" = 'Q' ]]; then
					exit 1
				fi
			fi
		else
			backupprompt
			read -t 120 -p " Continue?, defaults to Quit in 120 seconds C/Q? " usrChoice
			if [[ "$usrChoice" = 'q' || "$usrChoice" = 'Q' ]]; then
				exit 1
			fi
		fi
		
		# backup root's crontab file from directory root, or mount /var for crontab backup
		if [[ `grep -E '[[:space:]]/var[[:space:]]' /tmp/cfgbak/fstab` ]]; then
			varlv=`grep -E '[[:space:]]/var[[:space:]]' /tmp/cfgbak/fstab | awk '{print $1}'`
		else
			if [ -s /tmp/mnt/var/spool/cron/root ]; then
				echo "backing up root's crontab file" | tee -a /tmp/pre.log
				cp -P /tmp/mnt/var/spool/cron/root /tmp/cfgbak/root.cron
			fi
			
			# back up any fneserver trusted store data
			if [ -d /tmp/mnt/var/lib/fneserver ]; then
				cd /tmp/mnt/var/lib/fneserver
				tar -czf /tmp/cfgbak/fnetruststore.tgz --exclude='properties.xml' --exclude='FNEServer' *
				cd /
			fi
		fi
		
		umount /tmp/mnt
		sleep 2
	
		if [ $varlv ]; then
			mount $varlv /tmp/mnt
			sleep 2
			if [ -s /tmp/mnt/spool/cron/root ]; then
				echo "backing up root's crontab file" | tee -a /tmp/pre.log
				cp -P /tmp/mnt/spool/cron/root /tmp/cfgbak/root.cron
			fi
			
			# back up any fneserver trusted store data
			if [ -d /tmp/mnt/lib/fneserver ]; then
				cd /tmp/mnt/lib/fneserver
				tar -czf /tmp/cfgbak/fnetruststore.tgz --exclude='properties.xml' --exclude='FNEServer' *
				cd /
			fi
			umount /tmp/mnt
			sleep 2
		fi

		# shouldn't need this in 11.0, either install vanilla or upgrade
		# make sure user didn't select the worng menu item
		#if ! verify_upgrade_path
		#then 
		#	sleep 120
		#	chvt 1
		#	exit 1
		#fi

		# if warehouseconnector was retro installed attempt backup		
		if [ $warehouseconn ] && ! [[ `grep -E '[[:space:]]+/var/netwitness/warehouseconnector[[:space:]]+' /tmp/cfgbak/fstab` ]]; then
			nwlv=`grep -E '[[:space:]]+/var/netwitness[[:space:]]+' /tmp/cfgbak/fstab | awk '{print $1}'`
			echo "\$nwlv = $nwlv" | tee -a /tmp/pre.log
			echo "mounting $nwlv on /tmp/mpoint for warehouseconnector application folder backup" | tee -a /tmp/pre.log
			mount $nwlv /tmp/mpoint
			errcode=$?
			sleep 2
			if [ $errcode != 0 ]; then
				{ backupprompt "/tmp/cfgbak/warec.tgz"; read -t 120 -p " Continue?, defaults to Quit in 120 seconds C/Q? " usrChoice; if [[ "$usrChoice" = 'q' || "$usrChoice" = 'Q' ]]; then exit 1; fi }
			fi
			echo 'backing up warehouseconnector folder to /tmp/cfgbak/warec.tgz, this may take a while ...' | tee -a /tmp/pre.log
			tar -czf /tmp/cfgbak/warec.tgz -C /tmp/mpoint warehouseconnector/ ||
			{ backupprompt "/tmp/cfgbak/warec.tgz"; read -t 120 -p " Continue?, defaults to Quit in 120 seconds C/Q? " usrChoice; if [[ "$usrChoice" = 'q' || "$usrChoice" = 'Q' ]]; then exit 1; fi }
			umount /tmp/mpoint
			sleep 2
		fi

		# attempt local backup of /etc/fstab and /etc/netwitness incase of upgrade failure 
		local bkuproot
		case $nwapptype in
			# dell-s4s-1u: /var/netwitness not in VolGroup00
			archiver )
				bkuproot=`grep -E '[[:space:]]+/var/netwitness[[:space:]]+' /tmp/cfgbak/fstab | awk '{print $1}'`
			;;
			# broker volumes should exist in s3 - s4s hw
			broker | sabroker | spectrumbroker )
				bkuproot=`grep -E '[[:space:]]+/var/netwitness/broker[[:space:]]+' /tmp/cfgbak/fstab | awk '{print $1}'`
			;;
			# concentrator volumes won't exist in s4 - s4s hw without external storage
			concentrator )
				bkuproot=`grep -E '[[:space:]]+/var/netwitness/concentrator/metadb[[:space:]]+' /tmp/cfgbak/fstab | awk '{print $1}'`		
			;;
			# decoder volumes won't exist on s4 - s4s hw without external storage
			decoder | packethybrid | packetaio | spectrumdecoder )
				bkuproot=`grep -E '[[:space:]]+/var/netwitness/decoder/packetdb[[:space:]]+' /tmp/cfgbak/fstab | awk '{print $1}'`
			;;	
			# logdecoder volumes won't exist on s4 - s4s hw without external storage
			logdecoder | loghybrid | logaio )
				bkuproot=`grep -E '[[:space:]]+/var/netwitness/logdecoder/packetdb[[:space:]]+' /tmp/cfgbak/fstab | awk '{print $1}'`
			;;
			# dell-s4s-1u newport
			maprwh | esa )
				bkuproot=`grep -E '[[:space:]]+/opt[[:space:]]+' /tmp/cfgbak/fstab | awk '{print $1}'`		
			;;
			# remote logcollector: dell-s4-2u
			logcollector )
				bkuproot=`grep -E '[[:space:]]+/var/netwitness/logcollector[[:space:]]+' /tmp/cfgbak/fstab | awk '{print $1}'`
			;;
			# remote ipdbextractor: dell-s4-2u
			ipdbextractor )
				bkuproot=`grep -E '[[:space:]]+/var/netwitness/nwipdbextractor[[:space:]]+' /tmp/cfgbak/fstab | awk '{print $1}'`
			;;
		esac
		
		# series 4 and 4S nwx systems without an attached and configured JBOD enclosure
		if ! [[ `echo "$bkuproot" | grep -E '[[:alnum:]]'` ]]; then
			# nwhome on S4S not in VolGroup00
			if [ $nwsystem = dell-s4s-1u ]; then
				bkuproot=`grep -E '[[:space:]]+/var/netwitness[[:space:]]+' /tmp/cfgbak/fstab | awk '{print $1}'`
			# re-purpose nwhome in VolGroup00
			elif [ $nwsystem = dell-s4-1u ]; then
				usenwhome
				bkuproot=/dev/mapper/VolGroup00-nwhome
				baknwhome=true
			fi
		fi
		
		usrChoice=q 
		echo "attempting local disk backup of /tmp/cfgbak in: $bkuproot" | tee -a /tmp/pre.log
		mount $bkuproot /tmp/mnt | tee -a /tmp/pre.log
		if ! [[ `mount -l | grep '/tmp/mnt'` ]]; then
			mntfail=true
		fi
		# Series 4 and 4S nwx systems with JBOD enclosure disconnected
		if [ $mntfail ] && [[ $nwsystem = dell-s4-1u || $nwsystem = dell-s4s-1u ]]; then
			# nwhome on S4S not in VolGroup00
			if [ $nwsystem = dell-s4s-1u ]; then
				bkuproot=`grep -E '[[:space:]]+/var/netwitness[[:space:]]+' /tmp/cfgbak/fstab | awk '{print $1}'`
				echo "attempting local disk backup of /tmp/cfgbak in: $bkuproot" | tee -a /tmp/pre.log
				mount $bkuproot /tmp/mnt | tee -a /tmp/pre.log
				if [[ `mount -l | grep '/tmp/mnt'` ]]; then
					unset mntfail
				fi
			# re-purpose nwhome in VolGroup00
			elif [ $nwsystem = dell-s4-1u ] && ! [ $baknwhome ]; then
				usenwhome
				baknwhome=true 
				bkuproot=/dev/mapper/VolGroup00-nwhome
				echo "attempting local disk backup of /tmp/cfgbak in: $bkuproot" | tee -a /tmp/pre.log
				mount $bkuproot /tmp/mnt | tee -a /tmp/pre.log
				if [[ `mount -l | grep '/tmp/mnt'` ]]; then
					unset mntfail
				fi
			fi
		fi
	
		if ! [ $mntfail ]; then
			cp -R /tmp/cfgbak/ /tmp/mnt/
			exitcode=$?
		fi
		if [[ $mntfail || $exitcode != 0 ]]; then 
			backupprompt "/tmp/cfgbak"
			read -t 120 -p " Continue?, defaults to Quit in 120 seconds C/Q? " usrChoice
			if [[ "$usrChoice" = 'q' || "$usrChoice" = 'Q' ]]; then
				exit 1
			fi
		else
			umount /tmp/mnt
			sleep 2
		fi

		# parse mount components from existing /etc/fstab
		local index
		local numlines
		local mydevices
		local mymounts
		local myformats
		local myoptions
		local symlink
		local uuid
		local label
		local numloops
		local devname
		local deverr
	
		# set default to Install/Re-install
		#usrChoice='R'
				
		let count=0
		let index=0
		let numlines=${#sysmounts[@]}
		while [ $count -lt $numlines ]
		do 
			if [[ `echo "${sysmounts[$count]}" | grep -E '^[[:space:]]*#'` ]]; then
				let count=$count+1
				continue
			elif [[ `echo "${sysmounts[$count]}" | grep -E '^[[:space:]]*$'` ]]; then
				let count=$count+1
				continue
			# netwitness logical volume and block devices
			elif [[ `echo "${sysmounts[$count]}" | awk '{print $2}' | grep 'netwitness'` && `echo "${sysmounts[$count]}" | awk '{print $1}' | grep '/dev/'` ]]; then 
				mydevices[$index]=`echo "${sysmounts[$count]}" | awk '{print $1}'`
				mymounts[$index]=`echo "${sysmounts[$count]}" | awk '{print $2}'`
				myformats[$index]=`echo "${sysmounts[$count]}" | awk '{print $3}'` 
				#myoptions[$index]=`echo "${sysmounts[$count]}" | awk '{print $4}'`
				let index=$index+1
			elif [[ `echo "${sysmounts[$count]}" | awk '{print $2}' | grep '/var/lib/rabbitmq'` ]]; then 
				# if rabmqvol exists in a volume group other than VolGroup00 don't create it as it will be deleted and recreated
				if ! [[ `echo "${sysmounts[$count]}" | awk '{print $1}' | grep 'VolGroup00'` ]]; then
					mydevices[$index]=`echo "${sysmounts[$count]}" | awk '{print $1}'`
					mymounts[$index]=`echo "${sysmounts[$count]}" | awk '{print $2}'`
					myformats[$index]=`echo "${sysmounts[$count]}" | awk '{print $3}'` 
					#myoptions[$index]=`echo "${sysmounts[$count]}" | awk '{print $4}'`
					rabmqvol=true
					let index=$index+1
				fi
			elif [[ `echo "${sysmounts[$count]}" | awk '{print $1}' | grep '/dev/mapper'` ]]; then
				mydevices[$index]=`echo "${sysmounts[$count]}" | awk '{print $1}'`
				mymounts[$index]=`echo "${sysmounts[$count]}" | awk '{print $2}'`
				myformats[$index]=`echo "${sysmounts[$count]}" | awk '{print $3}'`
				let index=$index+1
			elif [[ `echo "${sysmounts[$count]}" | awk '{print $1}' | grep '/dev/md[0-9]'` || `echo "${sysmounts[$count]}" | awk '{print $1}' | grep '/dev/[hs]d[a-z][0-9]'` ]]; then
				mydevices[$index]=`echo "${sysmounts[$count]}" | awk '{print $1}'`
				mymounts[$index]=`echo "${sysmounts[$count]}" | awk '{print $2}'`
				myformats[$index]=`echo "${sysmounts[$count]}" | awk '{print $3}'`
				let index=$index+1
			elif [[ `echo "${sysmounts[$count]}" | awk '{print $1}' | grep -i 'VolGroup0'` ]]; then 
				mydevices[$index]=`echo "${sysmounts[$count]}" | awk '{print $1}'`
				mymounts[$index]=`echo "${sysmounts[$count]}" | awk '{print $2}'`
				myformats[$index]=`echo "${sysmounts[$count]}" | awk '{print $3}'`
				let index=$index+1
			# cifs/nfs mounts
			elif [[ `echo "${sysmounts[$count]}" | awk '{print $3}' | grep -i 'cifs'` || `echo "${sysmounts[$count]}" | awk '{print $3}' | grep -i 'nfs'` ]]; then 
				mydevices[$index]=`echo "${sysmounts[$count]}" | awk '{print $1}'`
				mymounts[$index]=`echo "${sysmounts[$count]}" | awk '{print $2}'`
				myformats[$index]=`echo "${sysmounts[$count]}" | awk '{print $3}'`
				myoptions[$index]=`echo "${sysmounts[$count]}" | awk '{print $4}'`			
				let index=$index+1		
			elif [[ `echo "${sysmounts[$count]}" | awk '{print $1}' | grep -i 'UUID'` ]]; then 
				# deference boot mounts for reuse by installer
				if [[ `echo "${sysmounts[$count]}" | awk '{print $2}' | grep -i '/boot'` ]]; then
					uuid=`echo "${sysmounts[$count]}" | awk -F= '{print $2}' | awk '{print $1}'`
					symlink=`ls -l /dev/disk/by-uuid | grep "$uuid"`
					symlink=`echo "$symlink" | awk -F\> '{print $2}' | awk '{print $1}'`
					symlink=${symlink#\.\./\.\./}
					mydevices[$index]="/dev/$symlink"
					mymounts[$index]=`echo "${sysmounts[$count]}" | awk '{print $2}'`
					myformats[$index]=`echo "${sysmounts[$count]}" | awk '{print $3}'`
					let index=$index+1
				else	
					mydevices[$index]=`echo "${sysmounts[$count]}" | awk '{print $1}'`
					mymounts[$index]=`echo "${sysmounts[$count]}" | awk '{print $2}'`
					myformats[$index]=`echo "${sysmounts[$count]}" | awk '{print $3}'`		
					let index=$index+1
				fi
			elif [[ `echo "${sysmounts[$count]}" | awk '{print $1}' | grep -i 'LABEL'` ]]; then 
				# deference boot mounts for reuse by installer
				if [[ `echo "${sysmounts[$count]}" | awk '{print $2}' | grep -i '/boot'` ]]; then 
					label=`echo "${sysmounts[$count]}" | awk -F= '{print $2}' | awk '{print $1}'`
					label=${label/\/}
					symlink=`ls -l /dev/disk/by-label | grep "$label"`
					symlink=`echo "$symlink" | awk -F\> '{print $2}' | awk '{print $1}'`
					symlink=${symlink#\.\./\.\./}
					mydevices[$index]="/dev/$symlink"
					mymounts[$index]=`echo "${sysmounts[$count]}" | awk '{print $2}'`
					myformats[$index]=`echo "${sysmounts[$count]}" | awk '{print $3}'`		
					let index=$index+1
				else
					mydevices[$index]=`echo "${sysmounts[$count]}" | awk '{print $1}'`
					mymounts[$index]=`echo "${sysmounts[$count]}" | awk '{print $2}'`
					myformats[$index]=`echo "${sysmounts[$count]}" | awk '{print $3}'`		
					let index=$index+1
				fi
			fi
			let count=$count+1	
		done
	        
		### debug statements ###
		#size=${#mydevices[@]}
		#let count=0
		#while [ $count -lt $size ]
		#do
		#	echo "${mydevices[$count]} ${mymounts[$count]} ${myformats[$count]}" > /dev/tty2
		#	let count=$count+1	
		#done
		#sleep 30
		#exit 1 

 		# get uuid of directory root, i.e. '/'
		let count=0
		let size=${#mymounts[@]}
		while [ $count -lt $size ]
		do
			if [[ `echo ${mymounts[$count]} | grep '/'` ]] && ! [[ `echo ${mymounts[$count]} | grep -E '/[[:alnum:]]+'` ]]; then
				rootlv=${mydevices[$count]}
				break
			fi
			let count=$count+1
		done	
		echo "determining uuid of $rootlv" >> /tmp/pre.log
		blkid $rootlv >> /tmp/pre.log
		# some commands don't work with idrac, seems to be some rpc latency going on?
		rootfsuuid=( `blkid $rootlv` )
		# spilt return string
		for i in ${rootfsuuid[@]}
		do
			if [[ `echo $i | grep -i 'UUID'` ]]; then
				rootfsuuid=$i
				echo "rootfsuuid = $rootfsuuid" >> /tmp/pre.log
				rootfsuuid=${rootfsuuid#UUID=\"}
				rootfsuuid=${rootfsuuid%\"}
				echo "rootfsuuid = $rootfsuuid" >> /tmp/pre.log
				break
			fi
		done
		echo "\$rootfsuuid = $rootfsuuid" >> /tmp/pre.log
		echo -n "$rootfsuuid" > /tmp/rootfsuuid.txt
		
		# verify devices 
		echo 'verifying block devices, volume groups and logical volumes ...'
		let numloops=${#mydevices[@]}
		let count=0
		echo
		while [ $count -lt $numloops ]
		do 
			if [[ `echo "${myformats[$count]}" | grep -i 'cifs'` || `echo "${myformats[$count]}" | grep -i 'nfs'` ]]; then
				echo "skipping cifs/nfs mount(s): ${mydevices[$count]}"
			elif [[ `echo "${mydevices[$count]}" | grep '/dev/[hs]d[a-z][0-9]'` || `echo "${mydevices[$count]}" | grep '/dev/md[0-9]'` ]]; then
				if ! [ -b  "${mydevices[$count]}" ]; then
					echo "device not found ${mydevices[$count]}"
					let deverr=1
				else
					echo "found: ${mydevices[$count]}"
				fi 
			elif [[ `echo "${mydevices[$count]}" | grep -i 'UUID'` ]]; then
				# deference device uuid
				uuid=`echo "${sysmounts[$count]}" | awk -F= '{print $2}' | awk '{print $1}'`
				symlink=`ls -l /dev/disk/by-uuid | grep "$uuid"`
				symlink=`echo "$symlink" | awk -F\> '{print $2}' | awk '{print $1}'`
				symlink=${symlink#\.\./\.\./}
				# block devices
				if ! [[ `echo $symlink | grep -i 'dm-'` ]]; then
					if ! [ -b  "/dev/$symlink" ]; then
						echo "device not found ${mydevices[$count]}"
						let deverr=1
					else
						echo "found: ${mydevices[$count]}"
					fi
				# logical devices
				else
					if ! [[ `ls -l /dev/mapper | grep "$symlink"` ]]; then
						echo "device not found ${mydevices[$count]}"
						let deverr=1
					fi
				fi 
			elif [[ `echo "${mydevices[$count]}" | grep '/dev/mapper'` ]]; then
				if ! [ -b  "${mydevices[$count]}" ]; then
					echo "device not found ${mydevices[$count]}"
					let deverr=1
				else
					echo "found: ${mydevices[$count]}"
				fi 
			else 
				if ! [ -h "${mydevices[$count]}" ]; then
					echo "device not found ${mydevices[$count]}"
					let deverr=1
				else
					echo "found: ${mydevices[$count]}"
				fi
			fi       	       
			let count=$count+1
		done
		
		### debug statements ###
		#echo 'sleeping indefinitely' > /dev/tty2
		#sleep 99999
		
		if [ $deverr ]; then
			# prompt for upgrade error
			echo
			echo "----------------------------------------------------------"
			echo " Dectection of all listed storage devices has failed"
			echo " Continuing with a upgrade may cause unexpected results"
			echo " Please quit and contact product support if upgrading"
			echo " Re-installs will delete all storage partitions and data"
			echo " Please quit and backup any needed data before proceeding"
			echo " Enter U to Upgrade, R to Re-Install, Q to Quit"
			echo "----------------------------------------------------------"
			usrChoice='Q'		
			read -t 120 -p " Upgrade/Re-install/Quit, defaults to Quit in 120 seconds U/R/Q? " usrChoice 
	
		else	
			# prompt for upgrade
			echo
			echo "-----------------------------------------------------"
			echo " This system appears to be eligble for an upgrade"
			echo " For upgrades only application data will be saved"
			echo " Any OS level volumes in VolGroup00 will be erased"
			echo " E.G. /etc, /home, /lib, /root, /usr, /var, etc."
			echo " Re-installs will delete all partitions and data"
			echo " Please quit and backup any data before proceeding"
			echo " Enter U to Upgrade, R to Re-Install, Q to Quit"
			echo "-----------------------------------------------------" > /dev/tty2
			usrChoice='U'
			read -t 120 -p " Upgrade/Re-install/Quit, defaults to Upgrade in 120 seconds U/R/Q? " usrChoice 
		fi

		if [[ "$usrChoice" = 'q' || "$usrChoice" = 'Q' ]]; then
			exit 1
		elif [[ "$usrChoice" = 'r' || "$usrChoice" = 'R' ]]; then 	
			#vgremove -f /dev/VolGroup00
			vgchange --monitor n
			vgchange -a n
			if [[ `grep '/dev/md[0-9]' /tmp/mdadm.conf` ]]; then
				local mdarray=( `grep '/dev/md[0-9]' /tmp/mdadm.conf | awk '{print $2}'` )
				for item in ${mdarray[@]}
				do
					mdadm -S $item | tee -a /tmp/pre.log
				done
			fi
			make_install_parts $nwsystem $usrChoice
		fi
		
		# add install of WC if installed previously, remove otherwise as it was only installed on SA 10.3+ s4s non aio capture appliances
		if [ $warehouseconn ]; then
			if ! [[ `grep 'nwwarehouseconnector' /tmp/nwpack.txt` ]]; then
				sed -r 's/(^[[:space:]]*%end.*$)/nwwarehouseconnector\n\1/' < /tmp/nwpack.txt > /tmp/nwpack.txt.tmp
				mv -f /tmp/nwpack.txt.tmp /tmp/nwpack.txt
			fi
		else
			if [[ `grep 'nwwarehouseconnector' /tmp/nwpack.txt` ]]; then
				sed -r 's/(^[[:space:]]*nwwarehouseconnector.*$)/#\1/' < /tmp/nwpack.txt > /tmp/nwpack.txt.tmp
				mv -f /tmp/nwpack.txt.tmp /tmp/nwpack.txt
			fi
		fi
		
		# add install of LC if installed previously, remove otherwise as it was only installed on NG 9.8+ s4 and s4s logdecoder appliances
		if [ $logcoll ]; then
			if ! [[ `grep 'setuplogcoll' /tmp/nwpost.txt` ]]; then
				sed -r 's/(^[[:space:]]*%end.*$)/setuplogcoll\n\1/' < /tmp/nwpost.txt > /tmp/nwpost.txt.tmp
				mv -f /tmp/nwpost.txt.tmp /tmp/nwpost.txt
			fi
		else
			if [[ `grep 'setuplogcoll' /tmp/nwpost.txt` ]]; then
				sed -r 's/(^[[:space:]]*setuplogcoll.*$)/#\1/' < /tmp/nwpost.txt > /tmp/nwpost.txt.tmp
				mv -f /tmp/nwpost.txt.tmp /tmp/nwpost.txt
				sed -r 's/^[[:space:]]*vsftpd.*$/-vsftpd/' < /tmp/nwpack.txt > /tmp/nwpack.txt.tmp
				mv -f /tmp/nwpack.txt.tmp /tmp/nwpack.txt 
				sed -r 's/^[[:space:]]*rssh.*$/-rssh/' < /tmp/nwpack.txt > /tmp/nwpack.txt.tmp
				mv -f /tmp/nwpack.txt.tmp /tmp/nwpack.txt
			fi
		fi

		echo "volgroup VolGroup00 --useexisting" >> $SYSPARTS
		
		# get list of logical volumes in VolGroup00
		vg00lv=( `ls /dev/VolGroup00` )
	
		### debug statements ###
		echo "logical volumes in VolGroup00: ${vg00lv[@]}" | tee -a /tmp/pre.log
		sleep 5
		#echo 'sleeping indefinitely' > /dev/tty2
		#sleep 99999 
		
		local lvdev
		local mpoint
		local blkdev
		local devfs
		local nospace
		local freespace
		local newrabmq
		local startfree
		local endfree
		local partnum
		local counter
		local mysize 
		for lvdev in "${vg00lv[@]}"
		do
			# delete os logical volumes from VolGroup00
			if ! [[ `echo $lvdev | grep -i 'concentrator'` ]] && ! [[ `echo $lvdev | grep -i 'ipdbext'` ]] && ! [[ `echo $lvdev | grep -i 'lchome'` ]] && ! [[ `echo $lvdev | grep -i '^home'` ]] && ! [[ `echo $lvdev | grep -i '^nwhome'` ]]; then
				
				### debug statement ###
				echo "deleting logical volume: $lvdev" | tee -a /tmp/pre.log
				lvremove -f /dev/VolGroup00/$lvdev
			# preserve nwhome on all models for now, delete later if not needed 
			# preserve other per appliance non os volumes in VolGroup00, 100 series concentrator, R710 logcollector and ipdbextractor, asus mini decoder no longer supported
			elif [[ `echo "$lvdev" | grep -i '^concentrator'` ]] || [[ `echo "$lvdev" | grep -i 'lchome'` ]] || [[ `echo "$lvdev" | grep -i 'ipdbext'` ]]; then
				let mysize=${#mydevices[@]}
				let counter=0
				while [ $counter -lt $mysize ]
				do
					if [[ `echo "${mydevices[$counter]}" | grep "/dev/VolGroup00/$lvdev"` || `echo "${mydevices[$counter]}" | grep "/dev/mapper/VolGroup00-$lvdev"` ]]; then
						echo "${mydevices[$counter]} ${mymounts[$counter]} ${myformats[$counter]}" >> $APPMNTS
					fi
					let counter=counter+1
				done
			fi
		done
		
		### debug statements ###
		#echo
		#echo 'sleeping indefinitely'
		#sleep 99999	
		
		
		# if series s4s check for newport configuration 
		if [ $nwsystem = dell-s4s-1u ]; then
			if check_for_newport_drives
			then	
				inewport=True
			fi
		fi	
		
		# create upgrade lv for user prompt flag and disaster recovery, remove in %post
		lvcreate -n rsaupgdtry -L 4M /dev/mapper/VolGroup00
		lvchange -ay /dev/mapper/VolGroup00-rsaupgdtry
		mkfs.xfs /dev/mapper/VolGroup00-rsaupgdtry
		mount -t xfs /dev/mapper/VolGroup00-rsaupgdtry /tmp/mnt
		echo -n "$bkuproot" > /tmp/mnt/bkuproot.txt
		echo -n "$rootfsuuid" > /tmp/mnt/rootfsuuid.txt
		umount /tmp/mnt

		# get physical volume size
		vgsize=`pvs --units g -o vg_name,pv_size | grep 'VolGroup00' | awk '{print $2}'`
		let vgsize=${vgsize%%\.[0-9]*[gG]}
		# not a dell r610 or r710
		if [ $vgsize -gt 100 ] && ! [[ $nwsystem = dell-s4-1u || $nwsystem = dell-s4-2U ]] ; then
			# remove netwitness volume, i.e. /var/netwitness	
			if [[ `ls /dev/mapper/VolGroup00-home` ]]; then
				echo "deleting logical volume: /dev/Volgroup00/home" | tee -a /tmp/pre.log
				lvremove -f /dev/VolGroup00/home
			elif [[ `ls /dev/mapper/VolGroup00-nwhome` ]]; then
				echo "deleting logical volume: /dev/Volgroup00/nwhome" | tee -a /tmp/pre.log
				lvremove -f /dev/VolGroup00/nwhome
			fi 
			echo "$upsz_root_volumes" >> $SYSPARTS
		# dell r610 nwx
		elif [[ $vgsize -gt 100 && $nwsystem = dell-s4-1u ]]; then
			if ! [ $baknwhome ]; then
				# remove netwitness volume, i.e. /var/netwitness	
				if [[ `ls /dev/mapper/VolGroup00-home` ]]; then
					echo "deleting logical volume: /dev/Volgroup00/home" | tee -a /tmp/pre.log
					lvremove -f /dev/VolGroup00/home
				elif [[ `ls /dev/mapper/VolGroup00-nwhome` ]]; then
					echo "deleting logical volume: /dev/Volgroup00/nwhome" | tee -a /tmp/pre.log
					lvremove -f /dev/VolGroup00/nwhome
				fi
				echo "$upsz_root_volumes" >> $SYSPARTS
			else
				echo '# OS partitions on the RAID 1 volume on the internal drives
logvol / --fstype=ext4 --name=root --vgname=VolGroup00 --size=16384
logvol swap --fstype=swap --name=swap --vgname=VolGroup00 --size=20480
logvol /tmp --fstype=ext4 --name=tmp --vgname=VolGroup00 --size=20480 --fsoptions="nosuid"
logvol /var --fstype=ext4 --name=var --vgname=VolGroup00 --size=12288
logvol /var/tmp --fstype=ext4 --name=vartmp --vgname=VolGroup00 --size=6144 --fsoptions="nosuid" 
logvol /home --fstype=ext4 --name=usrhome --vgname=VolGroup00 --size=2048 --fsoptions="nosuid"
logvol /var/lib/rabbitmq --fstype=xfs --name=rabmq --vgname=VolGroup00 --size=20480 --fsoptions="nosuid,noatime"' >> $SYSPARTS
			fi
		# series s4s non newport: r620 w/4 hdd, netwitness volume not in VolGroup00, i.e. sa core or sa server series 4s appliance
		elif [ $vgsize -lt 100 ] && [ $nwsystem = dell-s4s-1u ] && ! [ $inewport ]; then
			if ! [ $rabmqvol ]; then
				# check for free space in VolGroup01, first mirrored pair approximately 147 GB
				vgfreemb=`vgs --units m -o vg_name,vg_free | grep VolGroup01 | awk '{print $2}'`
				vgfreemb=${vgfreemb%%\.*}
				let vgfreemb=${vgfreemb%m}
				if [ $vgfreemb -ge 20480 ]; then
					echo 'logvol /var/lib/rabbitmq --vgname=VolGroup01 --size=20480 --fstype=xfs --name=rabmq --fsoptions="nosuid"' >> $SYSPARTS
				else
					nospace=true
				fi
			fi
			# move SD card /tmp volume to disk
			if [[ `grep -E 'VolGroup00.*[[:space:]]+/tmp[[:space:]]+' /tmp/cfgbak/fstab` ]]; then
				# check for free space in VolGroup01, first mirrored pair approximately 147 GB
				vgfreemb=`vgs --units m -o vg_name,vg_free | grep VolGroup01 | awk '{print $2}'`
				vgfreemb=${vgfreemb%%\.*}
				let vgfreemb=${vgfreemb%m}
				if [ $vgfreemb -ge 20480 ]; then
					echo 'logvol /tmp --vgname=VolGroup01 --size=20480 --fstype=xfs --name=tmp --fsoptions="nosuid"' >> $SYSPARTS
				else
					nospace=true
				fi
			fi
			# create non existing disk log volume
			if ! [[ `grep -E 'VolGroup01.*[[:space:]]+/var/log[[:space:]]+' /tmp/cfgbak/fstab` ]]; then
				# check for free space in VolGroup01, first mirrored pair approximately 147 GB
				vgfreemb=`vgs --units m -o vg_name,vg_free | grep VolGroup01 | awk '{print $2}'`
				vgfreemb=${vgfreemb%%\.*}
				let vgfreemb=${vgfreemb%m}
				if [ $vgfreemb -ge 10240 ]; then
					echo 'logvol /var/log --vgname=VolGroup01 --size=10240 --fstype=xfs --name=varlog --fsoptions="nosuid"' >> $SYSPARTS		
				else
					nospace=true
				fi			
			fi
			if [ $nospace ]; then
				echo "$old_eusb_root_volumes" >> $SYSPARTS
			else
				echo "$eusb_root_volumes" >> $SYSPARTS
                        fi
		# series s4s aio or hybrid and newport, i.e. r620 w/10 hdd, only available space is in VolGroup03 
		elif [ $vgsize -lt 100 ] && [ $nwsystem = dell-s4s-1u ] && [ $inewport ] && [[  $nwapptype = logaio || $nwapptype = loghybrid || $nwapptype = packetaio ]] || [ $nwapptype = packethybrid ]; then
			echo "$old_eusb_root_volumes" >> $SYSPARTS
			if ! [ $rabmqvol ]; then
				# check for free space in VolGroup03, single HW RAID0 volume approximatelt 933 GB
				vgfreemb=`vgs --units m -o vg_name,vg_free | grep VolGroup03 | awk '{print $2}'`
				vgfreemb=${vgfreemb%%\.*}
				let vgfreemb=${vgfreemb%m}
				if [ $vgfreemb -ge 20480 ]; then
					echo 'logvol /var/lib/rabbitmq --vgname=VolGroup03 --size=20480 --fstype=xfs --name=rabmq --fsoptions="nosuid"' >> $SYSPARTS		
				fi
			fi	
		# series s4s non aio, hybrid or maprwh and newport: r620 w/10 hdd, i.e. esa and possible archiver or broker on maprwh reinstalls
		elif [ $vgsize -lt 100 ] && [ $nwsystem = dell-s4s-1u ] && [ $inewport ] && ! [[  $nwapptype = logaio || $nwapptype = loghybrid || $nwapptype = packetaio ]] && ! [[ $nwapptype = packethybrid || $nwapptype = maprwh ]]; then
			# possible free space available in VolGroup01 physical volume
			echo "$eusb_root_volumes" >> $SYSPARTS 
			if ! [ $rabmqvol ]; then
				# check for free space in VolGroup01, HW RAID5 volume 
				vgfreemb=`vgs --units m -o vg_name,vg_free | grep VolGroup01 | awk '{print $2}'`
				vgfreemb=${vgfreemb%%\.*}
				let vgfreemb=${vgfreemb%m}
				if [ $vgfreemb -ge 20480 ]; then
					echo 'logvol /var/lib/rabbitmq --vgname=VolGroup01 --size=20480 --fstype=xfs --name=rabmq --fsoptions="nosuid"' >> $SYSPARTS
					newrabmq=true
				fi
				if ! [ $newrabmq ]; then 
					# check for free pv space
					freespace=`parted -s unit s "/dev/${installdev[1]}" print free | grep -i -E 'Free[[:space:]]+Space' | tail -n1 | awk '{print $3}'`
					let freespace=${freespace%s} 
					if [ $freespace -gt 41943040 ]; then
						startspace=`parted -s unit s "/dev/${installdev[1]}" print free | grep -i -E 'Free[[:space:]]+Space' | tail -n1 | awk '{print $2}'`
						let startspace=${startspace%s}
						endspace=`expr $startspace+41943040`
						parted -s /dev/${installdev[1]} unit s mkpart primary ext2 "$startspace"s "$endspace"s
						partnum=`parted -s /dev/${installdev[1]} print | grep -E '[[:digit:]]' | tail -n1 | awk '{print $1}'`
						parted -s /dev/${installdev[1]} set $partnum lvm on
						pvcreate -ff /dev/"${installdev[1]}$partnum"
						vgextend VolGroup01 /dev/"${installdev[1]}$partnum"
						echo 'logvol /var/lib/rabbitmq --vgname=VolGroup01 --size=1 --grow --fstype=xfs --name=rabmq --fsoptions="nosuid"' >> $SYSPARTS
						newrabmq=true
					fi
 				fi	
				
			fi	
		# series 100 supermicro, except series 100 supermicro concentrator and all of series 4, which had 100GB+ hdd
		elif [ $vgsize -lt 100 ] && ! [[ $nwsystem = dell-s4-2u || $nwsystem = dell-s4s-1u || $nwapptype = concentrator ]]; then 
			# remove netwitness volume, i.e. /var/netwitness	
			if [[ `ls /dev/mapper/VolGroup00-home` ]]; then
				echo "deleting logical volume: /dev/Volgroup00/home" | tee -a /tmp/pre.log
				lvremove -f /dev/VolGroup00/home
			elif [[ `ls /dev/mapper/VolGroup00-nwhome` ]]; then
				echo "deleting logical volume: /dev/Volgroup00/nwhome" | tee -a /tmp/pre.log
				lvremove -f /dev/VolGroup00/nwhome
			fi 
			echo "$root_volumes" >> $SYSPARTS
			if [ $rabmqvol ]; then
				echo 'logvol /var/netwitness --fstype=xfs --name=nwhome --vgname=VolGroup00 --size=1 --grow --fsoptions="nosuid,noatime"' >> $SYSPARTS
			else
				echo 'logvol /var/netwitness --fstype=xfs --name=nwhome --vgname=VolGroup00 --size=12288 --fsoptions="nosuid,noatime"
logvol /var/lib/rabbitmq --fstype=xfs --name=rabmq --vgname=VolGroup00 --size=1 --grow --fsoptions="nosuid,noatime"' >> $SYSPARTS
			fi
		# series 100 sm concentrator	
		elif [ $vgsize -lt 100 ] && ! [[ $nwsystem = dell-s4-2u || $nwsystem = dell-s4s-1u ]] && [ $nwapptype = concentrator ]; then 
			# remove netwitness volume, i.e. /var/netwitness	
			if [[ `ls /dev/mapper/VolGroup00-home` ]]; then
				echo "deleting logical volume: /dev/Volgroup00/home" | tee -a /tmp/pre.log
				lvremove -f /dev/VolGroup00/home
			elif [[ `ls /dev/mapper/VolGroup00-nwhome` ]]; then
				echo "deleting logical volume: /dev/Volgroup00/nwhome" | tee -a /tmp/pre.log
				lvremove -f /dev/VolGroup00/nwhome
			fi
			echo "$root_volumes" >> $SYSPARTS
			if [ $rabmqvol ]; then
				echo 'logvol /var/netwitness --fstype=xfs --name=nwhome --vgname=VolGroup00 --size=1 --grow --fsoptions="nosuid,noatime"' >> $SYSPARTS
			else
				echo 'logvol /var/netwitness --fstype=xfs --name=nwhome --vgname=VolGroup00 --size=12288 --fsoptions="nosuid,noatime"
logvol /var/lib/rabbitmq --fstype=xfs --name=rabmq --vgname=VolGroup00 --size=1 --grow --fsoptions="nosuid,noatime"' >> $SYSPARTS
			fi		 
		# Dell R710 logcollector
		elif [ $vgsize -lt 100 ] && [ $nwsystem = dell-s4-2u ] && [ $nwapptype = logcollector ]; then 
			# remove netwitness volume, i.e. /var/netwitness	
			if [[ `ls /dev/mapper/VolGroup00-home` ]]; then
				echo "deleting logical volume: /dev/Volgroup00/home" | tee -a /tmp/pre.log
				lvremove -f /dev/VolGroup00/home
			elif [[ `ls /dev/mapper/VolGroup00-nwhome` ]]; then
				echo "deleting logical volume: /dev/Volgroup00/nwhome" | tee -a /tmp/pre.log
				lvremove -f /dev/VolGroup00/nwhome
			fi 		
			# no space left to create rabbitmq volume
			echo 'logvol / --fstype=ext4 --name=root --vgname=VolGroup00 --size=8192
logvol swap --fstype=swap --name=swap --vgname=VolGroup00 --size=16384
logvol /tmp --fstype=ext4 --name=tmp --vgname=VolGroup00 --size=8192 --fsoptions="nosuid"
logvol /var --fstype=ext4 --name=var --vgname=VolGroup00 --size=4096
logvol /var/tmp --fstype=ext4 --name=vartmp --vgname=VolGroup00 --size=4096 --fsoptions="nosuid"
logvol /home --fstype=ext4 --name=usrhome --vgname=VolGroup00 --size=2048 --fsoptions="nosuid"
logvol /var/netwitness --fstype=xfs --name=nwhome --vgname=VolGroup00 --size=1 --grow --fsoptions="nosuid,noatime"' >> $SYSPARTS
		# Dell R710 ipdbextractor
		elif [ $vgsize -lt 100 ] && [ $nwsystem = dell-s4-2u ] && [ $nwapptype = ipdbextractor ]; then	
			# remove netwitness volume, i.e. /var/netwitness	
			if [[ `ls /dev/mapper/VolGroup00-home` ]]; then
				echo "deleting logical volume: /dev/Volgroup00/home" | tee -a /tmp/pre.log
				lvremove -f /dev/VolGroup00/home
			elif [[ `ls /dev/mapper/VolGroup00-nwhome` ]]; then
				echo "deleting logical volume: /dev/Volgroup00/nwhome" | tee -a /tmp/pre.log
				lvremove -f /dev/VolGroup00/nwhome
			fi
			# only one volume group VolGroup00 
			echo 'logvol / --fstype=ext4 --name=root --vgname=VolGroup00 --size=16384
ogvol swap --fstype=swap --name=swap --vgname=VolGroup00 --size=16384
logvol /tmp --fstype=ext4 --name=tmp --vgname=VolGroup00 --size=8192 --fsoptions="nosuid"
logvol /var --fstype=ext4 --name=var --vgname=VolGroup00 --size=12288
logvol /var/tmp --fstype=ext4 --name=vartmp --vgname=VolGroup00 --size=4096 --fsoptions="nosuid"
logvol /home --fstype=ext4 --name=usrhome --vgname=VolGroup00 --size=2048 --fsoptions="nosuid"
logvol /var/netwitness --fstype=xfs --name=nwhome --vgname=VolGroup00 --size=30720  --fsoptions="nosuid,noatime"
logvol /var/lib/rabbitmq --fstype=xfs --name=rabmq --vgname=VolGroup00 --size=20480  --fsoptions="nosuid,noatime"' >> $SYSPARTS
		fi
		
		# get installation logical block devices list
		detect_install_devices
		echo -n "installdev = " >> /tmp/pre.log
		echo "${installdev[@]}" >> /tmp/pre.log
		echo -n "installmodel = " >> /tmp/pre.log
		echo "${installmodel[@]}" >> /tmp/pre.log

		# generate upgrade partitioning schema 
		let numloops=${#mydevices[@]}
		let count=0
		# ignore all volumes other than VolGroup00, add mounts in %post
		while [ $count -lt $numloops ]
		do
			# standard partition
			# boot labels
			if [[ `echo "${mydevices[$count]}" | grep -i '/dev/[hs]d[a-z][0-9]'` ]]; then
				if [[ `echo  "${mymounts[$count]}" | grep -i '/boot'` ]]; then
					# incase /boot is not mounted as LABEL or UUID set by hardware and install method
					if [[ "$nwsystem" = 'dell-s4s-1u' || "$nwsystem" = 'dell-s4-1u' ]]; then
						devname="${installdev[0]}1"
					elif [ "$nwsystem" = 'dell-s3-2u' ]; then
						devname="${installdev[2]}1"
					elif [[ "$nwsystem" = 'dell-s3-1u' || "$nwsystem" = 'dell-s3-1u-brok' ]]; then
						devname="${installdev[0]}1"
					elif [[ "$nwsystem" = 'sm-s3-1u' || "$nwsystem" = 'sm-s3-1u-brok' ]] && [ $installtype ]; then
						devname=sdb1
					elif [[ "$nwsystem" = 'sm-s3-1u' || "$nwsystem" = 'sm-s3-1u-brok' ]] && ! [ $installtype ]; then
						devname=sda1				
					fi	
					if [[ `echo "${myformats[$count]}" | grep 'ext[2-3]'` ]]; then
						echo "part ${mymounts[$count]} --onpart=$devname --fstype=ext4" >> $SYSPARTS
						#echo "part ${mymounts[$count]} --onpart=$devname --fstype=ext4"
						#sleep 10
					else
						echo "part ${mymounts[$count]} --onpart=$devname --fstype=${myformats[$count]}" >> $SYSPARTS
						#echo "part ${mymounts[$count]} --onpart=$devname --fstype=${myformats[$count]}"
						#sleep 10
					fi
				else
					echo "${mydevices[$count]} ${mymounts[$count]} ${myformats[$count]}" >> $APPMNTS
				fi
			# label mounts
			elif [[ `echo "${mydevices[$count]}" | grep -i 'LABEL'` ]]; then
				echo "${mydevices[$count]} ${mymounts[$count]} ${myformats[$count]}" >> $APPMNTS 
			# uuid mounts
			elif [[ `echo "${mydevices[$count]}" | grep -i 'UUID'` ]]; then
				echo "${mydevices[$count]} ${mymounts[$count]} ${myformats[$count]}" >> $APPMNTS
			# software raid
			elif [[ `echo "${mydevices[$count]}" | grep -i '/dev/md[0-9]'` ]]; then
				# re-use linux raid boot mirror
				if [[ `echo  "${mymounts[$count]}" | grep -i 'boot'` ]]; then
					devname="${mydevices[$count]}"
					devname=${devname#/dev/}
					# /boot should always be a mirror
					local partone=`cat /proc/mdstat | grep "$devname" | awk '{print $5}'`
					partone=${partone%\[[0-9]\]}
					local parttwo=`cat /proc/mdstat | grep "$devname" | awk '{print $6}'`
					parttwo=${parttwo%\[[0-9]\]}
					if [[ `echo "${myformats[$count]}" | grep 'ext[2-3]'` ]]; then 
						#echo "raid ${mymounts[$count]} --device=$devname --useexisting $partone $parttwo --fstype=ext4" >> $SYSPARTS
						echo "raid ${mymounts[$count]} --device=$devname --useexisting --fstype=ext4" >> $SYSPARTS
					else
						#echo "raid ${mymounts[$count]} --device=$devname --useexisting $partone $parttwo --fstype=${myformats[$count]}" >> $SYSPARTS
						echo "raid ${mymounts[$count]} --device=$devname --useexisting --fstype=${myformats[$count]}" >> $SYSPARTS
					fi
				else
					echo "${mydevices[$count]} ${mymounts[$count]} ${myformats[$count]}" >> $APPMNTS
				
				fi
			# cifs/nfs	
			elif [[ `echo "${myformats[$count]}" | grep -i 'cifs'` || `echo "${myformats[$count]}" | grep -i 'nfs'` ]]; then 
				echo "${mydevices[$count]} ${mymounts[$count]} ${myformats[$count]} ${myoptions[$count]}" >> $APPMNTS
			# swap 	
			elif [[ `echo "${myformats[$count]}" | grep -i 'swap'` ]] && ! [[ `echo "${mydevices[$count]}" | grep -i 'VolGroup00'` ]]; then
				echo "${mydevices[$count]} ${mymounts[$count]} ${myformats[$count]}" >> $APPMNTS		
			# logical volume
			else
				# skip system volumes, VolGrouop00, unless using netwitness home as backup device
				if [[ `echo ${mydevices[$count]} | grep 'VolGroup00.nwhome'` && $baknwhome ]]; then
					echo "${mydevices[$count]} ${mymounts[$count]} xfs" >> $APPMNTS
				elif ! [[ `echo ${mydevices[$count]} | grep 'VolGroup00'` ]]; then
					echo "${mydevices[$count]} ${mymounts[$count]} ${myformats[$count]}" >> $APPMNTS
				else
					let count=$count+1
					continue
				fi
			fi

			let count=$count+1
		done
		
		# debug statements
		# verify /tmp/nwpart.txt
		#echo "completed upgrade function, sleeping indefinitely" > /dev/tty2
		#sleep 99999
		#exit 1
		
		chvt 1

	else
		# install/re-install system
		make_install_parts $nwsystem
	fi 
}

function sysreboot {
	echo
	echo
	echo "-------------------------------------------------"
	echo " System reboot required to continue installation"
	echo " Please run installation again on next restart"
	echo " Rebooting system in 15 seconds ..."
	echo "-------------------------------------------------"
	echo
	sleep 15
	exit 1
}

function getnumld {
	if [ -z $1 ]; then
		echo "raid adapter id parameter required, exiting"
		return 1
	fi
	local ADPID=$1
	local MEGACLI="${COMMAND_TOOL}"
	numld=`$MEGACLI -ldgetnum -a$ADPID | grep -i 'number' | awk -F: '{print $2}' | awk '{print $1}'`
	echo "number of vd on raid controller $ADPID: $numld" >> /tmp/pre.log
	return 0
}

function getoshddsize {
# determine size of sata planar internal drives	
	local blockdev
	local item
	local size
	local planarATA
	
	blockdev=( `ls /sys/block | grep 'sd[a-z]'` )
	for item in ${blockdev[@]}
	do
		if [[ `cat /sys/block/$item/device/vendor | grep -i 'ATA'` ]]; then
			planarATA=true
			break
		fi
	done
	if [ $planarATA ]; then
		size=`parted -s /dev/$item print | grep -i -E "^[[:space:]]*Disk[[:space:]]+/dev/$item" | awk '{print $3}'`
		let size=${size%%[a-zA-Z]*}
		if [ $size -ge 140 ]; then
			return 0
		else
			return 1
		fi
	fi	
	return 1
}

function make_install_parts {
# create anaconda bootloader and partition %include file for installs
	
	# define local variables
	local ksInclude='/tmp/nwks.cfg'
	
	# set global variable for uefi boot 
	if [[ `dmesg | grep -E -i 'Command[[:space:]]+Line:' | grep -i -E 'BOOT_IMAGE=/images/pxeboot/vmlinuz'` ]]; then
		bootmethod='uefi'
	fi

	if ! [ -z $2 ]; then
		local usrChoice
		chvt 8
 		exec < /dev/tty8 > /dev/tty8 2> /dev/tty8
		echo "-----------------------------------------------------"
		echo " This system is eligble for an Install or Re-install"
		echo " Installs/Re-installs clear all partitions and data"
		echo " If upgrading please quit and retry, if the problem"
		echo " persists quit again and contact product support"
		echo " Please quit and backup any data before proceeding"
		echo " Enter Y to Install/Re-install, Q to Quit"
		echo "-----------------------------------------------------"
		#read -p " Proceed or Quit, defaults to Yes in 120 seconds Y/Q? " usrChoice 
		read -t 120 -p " Proceed or Quit, defaults to Yes in 120 seconds Y/Q? " usrChoice
		if [[ "$usrChoice" = 'q' || "$usrChoice" = 'Q' ]]; then
			exit 1
		fi
	fi
	
	# determine if any lvm volume groups resident on internal storage have been detected by the installer kernel, requires restart
	local uselvm=true
	vgs > /tmp/vgs.txt 2>&1
	if ! [[ `grep -E 'VolGroup0[[:digit:]]+' /tmp/vgs.txt` ]]; then
		unset uselvm
	fi

        # get installation logical block devices list
	detect_install_devices
	echo -n "installdev = " >> /tmp/pre.log
	echo "${installdev[@]}" >> /tmp/pre.log
	echo -n "installmodel = " >> /tmp/pre.log
	echo "${installmodel[@]}" >> /tmp/pre.log

	if [ -z $1 ]; then
		#echo "invalid install parameter provided"
		#echo "install cannot continue, exiting"
		#sleep 30
		#exit 1
		#echo 'mark fix this'
		echo
	fi
	
	#local nwsystype="$1"
	local nwsystype=`cat /tmp/nwsystem | awk '{print $1}'`
	
	# create anaconda bootloader configuration, required for flash media installs
	# supported qualified hardware
	if [[ "${nwsystype}" != 'vmware' && "${nwsystype}" != 'thirdparty' ]]; then
		echo "bootloader --iscrypted --password=grub.pbkdf2.sha512.10000.3F2CB2489D51B990EA87B49F3469BF8835848124D1CF54E94863EA20755BCE65BC3BCA6C9102DE26C00AFC3D3953E5E77A0442479B69E5CCFBE0833C05070715.88268F8C9BE839BF32B82CE38264DBB14B55DA166014B4F4A77F8AFB7107FA0759ABBBDC6DADAD15D79C76665ECBC671A6CA38A11D303847E91DB5198595C9B6 --location=mbr --boot-drive=${installdev[0]}" >> ${ksInclude} 
	# vmware assume dvd install
	elif [ "${nwsystype}" = 'vmware' ]; then
		echo "bootloader --iscrypted --password=grub.pbkdf2.sha512.10000.3F2CB2489D51B990EA87B49F3469BF8835848124D1CF54E94863EA20755BCE65BC3BCA6C9102DE26C00AFC3D3953E5E77A0442479B69E5CCFBE0833C05070715.88268F8C9BE839BF32B82CE38264DBB14B55DA166014B4F4A77F8AFB7107FA0759ABBBDC6DADAD15D79C76665ECBC671A6CA38A11D303847E91DB5198595C9B6 --location=mbr" >> ${ksInclude}
	# third party, not commited to for this sprint
	elif [ "${nwsystype}" = 'thirdparty' ]; then
		echo 
	fi

	if ! [ $numld ]; then
		if [ "$nwsystype" = 'dell-s4-1u' ]; then
			getnumld 1
		else
			getnumld 0
		fi
	fi

	# get os hdd size for intel mckay creek/sm 1200/1200n/2400/2400n appliances
	# planar ATA disks, sizes vary from 73 GB - 160 GB
	local upsizeos
	if getoshddsize 
	then
		upsizeos=true
	fi	
	
	# create install/re-install partitioning schema

	### Bootstrap ###
	
	# configure boot partition on all hardware systems
	if ! [[ ${vmware} || ${thirdparty} ]]; then
		# default msdos boot
		if ! [ ${bootmethod} ]; then
			echo "part /boot --size=512 --fstype=xfs --ondisk=${installdev[0]}" >> ${ksInclude}
		# gpt boot
		else
			echo "part /boot --size=512 --fstype=xfs --ondisk=${installdev[0]}
part /boot/efi --size=256 --fstype=vfat --ondisk=${installdev[0]}" >> ${ksInclude}
		fi
	fi
 
        # series 4 - series 5 head units
	if [ "${nwsystype}" = 'dell-s4-1u' ] || [ "${nwsystype}" = 'dell-s4s-1u' ] || [ "${nwsystype}" = 'dell-s9-1u' ] && ! [ ${iseries7} ] && ! [ ${inewport} ] && [ "${nwapptype}" = 'bootstrap' ]; then
		echo "creating partition script for series 4 - series 5 head unit appliance" >> /tmp/pre.log
		# two HW RAID1 Devices: VD0, VD1
		mk_disk_labels ${installdev[@]}
		if [ $uselvm ]; then
			sysreboot
		fi
		echo "part pv.vd0 --size=1 --grow --ondisk=/dev/${installdev[0]}
part pv.vd1 --size=1 --grow --ondisk=/dev/${installdev[1]}
volgroup netwitness_vg00 pv.vd0 pv.vd1
logvol swap --name=lv_swap0 --vgname=netwitness_vg00 --fstype=swap --size=4096
logvol /home --name=lv_usrhome --vgname=netwitness_vg00 --size=10240 --fstype=xfs --fsoptions=nosuid
logvol / --name=lv_sysroot --vgname=netwitness_vg00 --size=1 --grow --fstype=xfs" >> ${ksInclude}
        
	# series 9 esa appliance
	elif [[ "${nwsystype}" = 'dell-s9-1u' ]] && [ ${iseries7} ] && [ "{$nwapptype}" = 'bootstrap' ]; then
		echo "creating partition script for series 7 esa appliance" >> /tmp/pre.log
		# one HW RAID1 and one HW RAID5 device: VD0, VD1
		mk_disk_labels ${installdev[@]}
		if [ $uselvm ]; then
			sysreboot
		fi
		echo "part pv.vd0 --size=1 --grow --ondisk=/dev/${installdev[0]}
part pv.vd1 --size=1 --grow --ondisk=/dev/${installdev[1]}
volgroup netwitness_vg00 pv.vd0
logvol swap --name=lv_swap0 --vgname=netwitness_vg00 --size=4096
logvol /home --name=lv_usrhome --vgname=netwitness_vg00 --size=10240 --fstype=xfs --fsoptions=nosuid
logvol / --name=lv_sysroot --vgname=netwitness_vg00 --size=1 --grow --fstype=xfs
volgroup netwitness_vg01 pv.vd1
logvol /var/lib/netwitness --name=lv_nwappdata --vgname=netwitness_vg01 --size=1 --grow --fstype=xfs" >> ${ksInclude}

	elif [ "$nwsystype" = 'vmware' ]; then
#		mk_disk_labels ${installdev[@]}
#		echo "part biosboot --size=1
#part /boot --size=1024 --fstype=xfs
#part pv.root --size=1 --grow
#volgroup VolGroup00 pv.root
#logvol swap --name=lv_swap00 --vgname=VolGroup00 --size=4096 
#logvol /home --name=lv_usrhome --vgname=VolGroup00 --size=4096 --fstype=xfs --fsoptions=nosuid
#logvol / --name=lv_sysroot --vgname=VolGroup00 --size=1 --grow fstype=xfs" >> ${ksInclude}
		echo 'zerombr
part swap --size=4096
part / --size=1 --grow --fstype=xfs' >> ${ksInclude}
	### un-qualified appliance type ###
	else
		chvt 8 
		echo -e " %pre install error: make_install_parts()\n unable to create partition script for $nwapptype on $nwsystype hardware\n no installation/upgrade method available"
		promptReboot
	fi
	chvt 1
}

function check_nwx_drives
{
     	# make sure the drive pairs are installed in the correct slots
	# internal drive sizes in decimal GB/TB, i.e. marketed sizes
	# e.g. 160GB, 1000GB, 1TB, 2TB, etc. these sizes must be based 
	# on the drive scales determined by the controller,
	# i.e. MegaCli -pdlist -aall
	# 1TB ~= 1000GB 
	local sysDriveSize
	if [ -z $1 ]; then
		sysDriveSize='160GB'
	else
		sysDriveSize=$1
	fi 
	local appDriveSize
	if [ -z $2 ]; then
		appDriveSize='1000GB'
	else
		appDriveSize=$2
	fi

	# get size scale 
	local sysDrvScale=`expr "$sysDriveSize" : '.*\(.[bB]\)'`
	local appDrvScale=`expr "$appDriveSize" : '.*\(.[bB]\)'`
	# strip off scale
	sysDriveSize="${sysDriveSize%%[[:alpha:]]*}"
	appDriveSize="${appDriveSize%%[[:alpha:]]*}"

	# get raid adapter count
	local numadp=`$COMMAND_TOOL -adpcount  | grep -i 'Controller Count:' | awk -F: '{print $2}'`
	let numadp="${numadp%.}"
	# if more than one get PERC ID
	if [[ $numadp -gt 1 ]]; then
		local count
		local percID
		let count=0
		while [[ $count -lt $numadp ]]
		do
			if [[ `$COMMAND_TOOL -adpallinfo -a$count | grep -i 'Product Name' | grep -i 'PERC H700 Integrated'` ]]; then
				percID=$count
				echo "$count" > /tmp/intAdapterId
				break
			fi
		let count=$count+1
		done
		# Intel NWX has integrated controller at ID: 0
		if ! [ $percID ]; then
			percID='0'
		fi	
	else
		percID='0'
	fi 
	
	# check number of physical drives on PERC
	local numPD
	let numPD=`$COMMAND_TOOL -pdlist -a$percID | grep -ic 'PD Type:'`
	if [[ $numPD -lt 4 ]]; then 
		echo "Only $numPD of 4 required physical disks were found, install cannot continue"
		return 1		
	fi
	
	# check slot numbers of populated physical disks 
	let count=0
	local encID
	local errorCount
	local pdStat
	local pdSize
	local pdScale
	let errorCount=0
	encID=$("$COMMAND_TOOL" -pdlist -a$percID | while read p1 p2 p3 p4; do if [ "$p1" == "Enclosure" ]; then echo $p4; break; fi; done)

	while [ $count -lt 4 ]
	do
		if ! [[ `$COMMAND_TOOL -pdinfo -physdrv [$encID:$count] -a$percID | grep -i 'PD Type:'` ]]; then 
			let errorCount=$errorCount+1
			break
		else
			pdSize=`$COMMAND_TOOL -pdinfo -physdrv [$encID:$count] -a$percID | grep -i 'Raw Size:'`
			pdScale=`echo $pdSize | awk '{print $4}'`
			pdSize=`echo $pdSize | awk '{print $3}'`
			pdSize="$pdSize$pdScale"
			pdStat[$count]=$pdSize
			
		fi
		let count=$count+1
	done 
	
	if [[ $errorCount -gt 0 ]]; then
		#echo "encID = $encID percID = $percID"
		echo "Drives missing or not populated in slots 0 - 3, installation cannot continue"
	       	return 1
	fi

	# check that drive sizes are in pairs for slots: 0 - 1 & 2 - 3
        if [[ "${pdStat[0]}" != "${pdStat[1]}" || "${pdStat[2]}" != "${pdStat[3]}" ]]; then
		echo "Drive sizes in slots 0 - 1 or 2 - 3 do not match, installation cannot continue"
		return 1
	fi
	
	# strip scale specifier from raw drive size
	local pairSize1="${pdStat[0]%%[(A-Z|a-z)]*}"
	local pairSize2="${pdStat[2]%%[(A-Z|a-z)]*}" 
	
	# round off sizes	
	let pairSize1=`printf %.0f $pairSize1`
	let pairSize2=`printf %.0f $pairSize2`

	# convert advertized hard drive decimal sizes to GiB/TiB sizes	
	local gibSize1=`python -c "var = $sysDriveSize - $sysDriveSize * 0.074; print var"`
	let gibSize1=`printf %.0f $gibSize1`
	local gibSize2=`python -c "var = $appDriveSize - $appDriveSize * 0.074; print var"`
	let gibSize2=`printf %.0f $gibSize2`
	
	# check if drives sizes are within specifications
	
	# compute error percentage, +/- 5%
	local percentErr1=`python -c "var = $sysDriveSize * 0.05; print var"`
	local percentErr2=`python -c "var = $appDriveSize * 0.05; print var"`
	let percentErr1=`printf %.0f $percentErr1`
	let percentErr2=`printf %.0f $percentErr2`
	local pdSizeDelta1
	local pdSizeDelta2
	let pdSizeDelta1=$pairSize1-$gibSize1
	let pdSizeDelta2=$pairSize2-$gibSize2

	# convert any negative differences to positive
	if [[ $pdSizeDelta1 -lt 0 ]]; then
		let pdSizeDelta1=$pdSizeDelta1*-1
	elif [[ $pdSizeDelta2 -lt 0 ]]; then
		let pdSizeDelta2=$pdSizeDelta2*-1 
	fi
	
	# check approximate drive sizes 
	local gibDiff
	# mirror 0, system
	if ! [[ $pdSizeDelta1 -le $percentErr1 ]]; then
		gibDiff=`python -c "var = $pairSize1 * 0.074; print var"`
		gibDiff=`printf %.0f $gibDiff`
		let pairSize1=$pairSize1+$gibDiff
		pdScale=`expr "${pdStat[0]}" : '.*\(.[bB]\)'`
		echo "Drives in slots 0 - 1 are not $sysDriveSize $sysDrvScale they are $pairSize1 $pdScale models, installation cannot continue" 
		return 1
	fi
	# mirror 1, application
	if ! [[ $pdSizeDelta2 -le $percentErr2 ]]; then
		gibDiff=`python -c "var = $pairSize2 * 0.074; print var"`
		gibDiff=`printf %.0f $gibDiff`
		let pairSize2=$pairSize2+$gibDiff
		pdScale=`expr "${pdStat[2]}" : '.*\(.[bB]\)'` 
		echo "Drives in slots 2 - 3 are not $appDriveSize $appDrvScale they are $pairSize2 $pdScale models, installation cannot continue" 
		return 1
	fi
	
	return 0
}

function check_enc_drive_sizes
{
     	# make sure the specified drive sizes are installed in the correct slots
	# paramter drive sizes i.e. marketed sizes are specified in decimal
	# e.g. 160GB, 1000GB, 1TB, 2TB, etc. these sizes must match the binary
	# drive sizes as determined by the controller within (+/-) 5% after the
	# size conversion: 1000GB Base10 ~= 931GB Base2, if not provided`the
	# parmeter scale is assumed to be GB
	local errorstr
	local mylog='/tmp/pre.log'
	local driveSizes
	local driveScales
	local encSizes
	local encScales
	declare -a driveSizes
	declare -a driveScales
	declare -a encSizes
	declare -a encScales
	local drvsize
	local drvscale
	local count
	local numparam
	local paramsize
	local usrin='N'
	local gb2gib
	local percentErr
	local pdSizeDelta
	local encID
	local errorCount
	local pdSize
	local pdScale
	let count=0
	while ! [ -z $1 ]
	do
		drvscale=`expr "$1" : '.*\([A-Za-z][A-Za-z]\)'`
		if [ -z $drvscale ]; then
			drvscale='GB'
		fi
		drvscale=`echo ${drvscale} | tr [a-z] [A-Z]`
		drvsize="${1%%[[:alpha:]]*}"
		driveSizes[$count]=$drvsize
		driveScales[$count]=$drvscale
		#echo "get param $1"
		shift
		let count=$count+1
	done

	let numparam=${#driveSizes[@]}
	# Series 4, R610
	if [ $numparam -lt 4 ]; then
		driveSizes[0]='160'
		driveScales[0]='GB'
		driveSizes[1]='160'
		driveScales[1]='GB'
		driveSizes[2]='1000'
		driveScales[2]='GB'
		driveSizes[3]='1000'
		driveScales[3]='GB'
	fi
	let numparam=${#driveSizes[@]}

	# get raid adapter count
	local numadp=`$COMMAND_TOOL -adpcount  | grep -i 'Controller Count:' | awk -F: '{print $2}'`
	let numadp="${numadp%.}"
	# if more than one get PERC ID
	if [[ $numadp -gt 1 ]]; then
		local percID
		let count=0
		while [[ $count -lt $numadp ]]
		do
			if [[ `$COMMAND_TOOL -adpallinfo -a$count | grep -i 'Product Name' | grep -i 'PERC H700 Integrated'` ]]; then
				percID=$count
				break
			fi
		let count=$count+1
		done
		# Intel NWX has integrated controller at ID: 0
		if ! [ $percID ]; then
			percID='0'
		fi
	else
		percID='0'
	fi

	# check number of physical drives on PERC
	local numPD
	let numPD=`$COMMAND_TOOL -pdlist -a$percID | grep -ic 'PD Type:'`
	if [[ $numPD -lt $numparam ]]; then
		errorstr="Only $numPD of $paramsize required physical disks were found"
		echo > /dev/tty2
		echo > /dev/tty2
		echo 'calling %pre function: check_nwx_drives()' | tee -a $mylog > /dev/tty2
		echo "$errorstr" | tee -a $mylog
	fi

	# get stats of populated physical disks
	let count=0
	let errorCount=0
	encID=$("$COMMAND_TOOL" -pdlist -a$percID | while read p1 p2 p3 p4; do if [ "$p1" == "Enclosure" ]; then echo $p4; break; fi; done)

	while [ $count -lt $numparam ]
	do
		if ! [[ `$COMMAND_TOOL -pdinfo -physdrv [$encID:$count] -a$percID | grep -i 'PD Type:'` ]]; then
			let errorCount=$errorCount+1
			break
		else
			pdSize=`$COMMAND_TOOL -pdinfo -physdrv [$encID:$count] -a$percID | grep -i 'Raw Size:'`
			pdScale=`echo $pdSize | awk '{print $4}'`
			pdScale=`echo ${pdScale} | tr [a-z] [A-Z]`
			pdSize=`echo $pdSize | awk '{print $3}'`
			encSizes[$count]=$pdSize
			encScales[$count]=$pdScale
		fi
		let count=$count+1
	done
	
	if [[ $errorCount -gt 0 ]]; then
		#echo "encID = $encID percID = $percID"
		if [ $errorstr ]; then
			errorstr="${errorstr}\nMissing Drive, slot: $count not populated"
		else
			errorstr="Missing Drive, slot: $count not populated"
		fi
	fi

	if [ $numparam -eq 4 ]; then
		# check that drive sizes are in pairs for slots: 0 - 1
		if [[ "${encSizes[0]}${encScales[0]}" != "${encSizes[1]}${encScales[1]}" ]]; then
			if [ $errorstr ]; then
				errorstr="${errorstr}\nDrive sizes in slots 0 - 1 do not match"
			else
				errorstr="Drive sizes in slots 0 - 1 do not match"
			fi
		fi
		# check that drive sizes are in pairs for slots: 2 - 3
		if [[ "${encSizes[2]}${encScales[2]}" != "${encSizes[3]}${encScales[3]}" ]]; then
			if [ $errorstr ]; then
				errorstr="${errorstr}\nDrive sizes in slots 2 - 3 do not match"
			else
				errorstr="Drive sizes in slots 2 - 3 do not match"
			fi
		fi
	elif [ $numparam -eq 6 ]; then
		# check that drive sizes are in pairs for slots: 0 - 1
		if [[ "${encSizes[0]}${encScales[0]}" != "${encSizes[1]}${encScales[1]}" ]]; then
			if [ $errorstr ]; then
				errorstr="${errorstr}\nDrive sizes in slots 0 - 1 do not match"
			else
				errorstr="Drive sizes in slots 0 - 1 do not match"
			fi
		fi
		# check that drive sizes are in pairs for slots: 2 - 5
		if [ "${encSizes[2]}${encScales[2]}" != "${encSizes[3]}${encScales[3]}" ] && [ "${encSizes[3]}${encScales[3]}" != "${encSizes[4]}${encScales[4]}" ] && [ "${encSizes[4]}${encScales[4]}" != "${encSizes[5]}${encScales[5]}" ]; then
			if [ $errorstr ]; then
				errorstr="${errorstr}\nDrive sizes in slots 2 - 5 do not match"
			else
				errorstr="Drive sizes in slots 2 - 5 do not match"
			fi
		fi
	fi

	# validate drive size parameters
	let count=0
	while [ $count -lt $numparam ]
	do
		paramsize="${driveSizes[$count]}"
		encsize="${encSizes[$count]}"
		# check drive scales
		if [ "${driveScales[$count]}" != "${encScales[$count]}" ]; then
			if [[ "${driveScales[$count]}" = 'TB' && "${encScales[$count]}" = 'GB' ]]; then
				encsize=`python -c "myvar = $encsize; print myvar / 1024"`
			elif [[ "${driveScales[$count]}" = 'GB' && "${encScales[$count]}" = 'TB' ]]; then
				encsize=`python -c "myvar = $encsize; print myvar * 1024"`
			fi
		fi

		# round off sizes
		let paramsize=`printf %.0f $paramsize`
		let encsize=`printf %.0f $encsize`

		if [ "${driveScales[$count]}" = 'GB' ]; then
			gb2gib=`python -c "var = $paramsize; print var * 1000**3 / 1024**3"`
		elif [ "${driveScales[$count]}" = 'TB' ]; then
			gb2gib=`python -c "var = $paramsize; print var * 1000**3 / 1024**3"`
		fi
		let gb2gib=`printf %.0f $gb2gib`
		#echo "gb2gib = $gb2gib"
		# check if drives sizes are within specifications
		# compute error percentage, (+/-) 5%
		percentErr=`python -c "var = ${gb2gib}; print var * 0.05"`
		let percentErr=`printf %.0f $percentErr`
		if [ $encsize -lt $gb2gib ];then
			let pdSizeDelta=$encsize-$gb2gib
			# convert any negative differences to positive
			if [[ $pdSizeDelta -lt 0 ]]; then
				let pdSizeDelta=$pdSizeDelta*-1
			fi
			#echo "percentErr = $percentErr"
			#echo "pdSizeDelta = $pdSizeDelta"
			# verify approximate drive size
			if ! [ $pdSizeDelta -le $percentErr ]; then
				if [[ $errorstr ]]; then
					errorstr="${errorstr}\nDrive size in slot: $count ${encSizes[$count]}${encScales[$count]} is smaller than specified ${driveSizes[$count]}${driveScales[$count]}"
				else
					errorstr="Drive size in slot: $count ${encSizes[$count]}${encScales[$count]} is smaller than specified ${driveSizes[$count]}${driveScales[$count]}"
				fi
			fi
		fi
		let count=$count+1
	done

	# on error prompt to continue
	if  [[ $errorstr ]]; then
		if [[ `dmesg | grep -E -i 'Kernel[[:space:]]+command[[:space:]]+line:' | grep "ks=http://${pxetesthost}"` ]]; then
			echo 'Drive Errors Detected: continuing may cause unexpected results' | tee -a $mylog > /dev/tty2
			echo -e "${errorstr}" | tee -a $mylog > /dev/tty2		
			return 0
		else
			exec < /dev/tty2 > /dev/tty2 2> /dev/tty2
			chvt 2
			echo > /dev/tty2
			echo > /dev/tty2
			echo 'Drive Errors Detected: continuing may cause unexpected results' | tee -a $mylog > /dev/tty2
			echo -e "${errorstr}" | tee -a $mylog > /dev/tty2
			read -t 120 -p 'Enter (c/C) to continue install, Defaults to No in 120 seconds? ' usrin
			if [[ "${usrin}" = 'c' || "${usrin}" = 'C' ]]; then
				return 0
			else
				return 1
			fi
		fi
	fi

	return 0
}

function check_dell_bootstrap_mirrors
# check for mirrored pairs in slots 0 - 1 and slots 2 - 3 
{
	local numLD
	local adpID
	local count
	local raidLevel
	local numDrives
	
	# set internal perc id
	if [ "${nwsystem}" = 'dell-s4-1u' ]; then
		adpID=1
	else
		adpID=0
	fi
	
	numLD=`$COMMAND_TOOL -adpallinfo -a${adpID} | grep -i 'Virtual *Drives' | awk '{print $4}'`
	if [ "$numLD" != 2 ]
	then
		echo "Invalid or no RAID configuration found: #LD = $numLD" >> /dev/tty8
                echo "Applying new RAID configuration" >> /dev/tty8 
		return 1
        fi
 	
	let count=0
	while [ $count -lt 2 ]
	do
		raidLevel=`$COMMAND_TOOL -ldinfo -l$count -a${adpID} | grep -i -E 'RAID[[:space:]]+Level[[:space:]]+:' | awk '{print $4}'`
		numDrives=`$COMMAND_TOOL -ldinfo -l$count -a${adpID} | grep -i -E 'Number[[:space:]]+Of[[:space:]]+Drives[[:space:]]+:' | awk '{print $5}'` 
		if ! [[ `echo $raidLevel | grep -i 'Primary-1'` &&  "$numDrives" = '2' ]]
		then
			echo "Invalid or no RAID configuration found: RAID Level = $raidLevel #HDD = $numDrives" >> /dev/tty8
			echo "Applying new RAID configuration" >> /dev/tty8 
			return 1
		fi
		let count=$count+1
	done 
	
	return 0
}

function check_for_newport_drives
{
	if ! [ "$nwsystem" = 'dell-s4s-1u' ]; then
		echo 'Can not run check_for_newport_drives() on non S4S HW' >> /tmp/pre.log
		return 1
	fi 
	local ENCID=$("$COMMAND_TOOL" -pdlist -a0 | while read p1 p2 p3 p4; do if [ "$p1" == "Enclosure" ]; then echo $p4; break; fi; done) 
        local pdisk=`$COMMAND_TOOL -adpallinfo -a0 | grep -A1 -i -E 'Physical[[:space:]]+Devices' | grep -i 'Disks' | awk -F: '{print $2}' | awk '{print $1}'`
	let pdisk=$pdisk
	if [ $pdisk -lt 10 ]; then
		echo 'Series 4S Non Newport configuration detected' >> /tmp/pre.log            	
		return 1
	fi
	local ADAPTER=0	
	local count
	local drvError
	local drvsize
	local givensize
	let givensize=931
	local sizelo
        percenterr=`python -c "var = $givensize * 0.05;print var"`
       	let percenterr=${percenterr%%\.*}
	let sizelo=$givensize-$percenterr
	let drvError=0
	let count=0
	while [ $count -lt 10 ]
	do
	     drvsize=`$COMMAND_TOOL -pdinfo -physdrv[$ENCID:$count] -a$ADAPTER | grep -i 'Raw Size:' | awk -F: '{print $2}' | awk '{print $1}'`
             drvsize=${drvsize%%\.*}
             let drvsize=$drvsize
	     if ! [ $drvsize -ge $sizelo ]; then 
                 let drvError=$drvError+1 
             fi 
             let count=$count+1
        done
	if [ $drvError -gt 0 ]; then
		echo 'Series 4S Non Newport configuration detected' >> /tmp/pre.log            	
		return 1
        fi 
	echo 'Series 4S Newport configuration detected' >> /tmp/pre.log
	return 0
}

function check_for_s7_drives
{
	if ! [ "$nwsystem" = 'dell-s9-1u' ]; then
		echo 'Can not run check_for_s7_drives() on non dell R630 HW' >> /tmp/pre.log
		return 1
	fi 
	local ENCID=$("$COMMAND_TOOL" -pdlist -a0 | while read p1 p2 p3 p4; do if [ "$p1" == "Enclosure" ]; then echo $p4; break; fi; done) 
        local pdisk=`$COMMAND_TOOL -adpallinfo -a0 | grep -A1 -i -E 'Physical[[:space:]]+Devices' | grep -i 'Disks' | awk -F: '{print $2}' | awk '{print $1}'`
	let pdisk=$pdisk
	if [ $pdisk -lt 6 ]; then
		echo 'Series s9 configuration detected' >> /tmp/pre.log            	
		return 1
	fi
	local ADAPTER=0	
	local count
	local drvError
	local drvsize
	local givensize
	local givensize2
	local percenterr
	local percenterr2
	local sizelo
        local sizelo2

	let givensize=1000
	let givensize2=2000 
	percenterr=`python -c "var = $givensize * 0.05;print var"`
       	percenterr2=`python -c "var = $givensize2 * 0.05;print var"`
	let percenterr=${percenterr%%\.*}
	let percenterr2=${percenterr2%%\.*} 
	let sizelo=$givensize-$percenterr
	let sizelo2=$givensize2-$percenterr2
	let drvError=0
	let count=0
	while [ $count -lt 6 ]
	do
		drvsize=`$COMMAND_TOOL -pdinfo -physdrv[$ENCID:$count] -a$ADAPTER | grep -i 'Raw Size:' | awk -F: '{print $2}' | awk '{print $1}'`
		drvsize=${drvsize%%\.*}
		let drvsize=$drvsize
		if [ $count -lt 2 ]; then 
			if ! [ $drvsize -ge $sizelo ]; then 
		                 let drvError=$drvError+1 
			fi
		else 
			if ! [ $drvsize -ge $sizelo2 ]; then 
		                 let drvError=$drvError+1 
			fi
		fi
		let count=$count+1
	done
	if [ $drvError -gt 0 ]; then
		echo 'Series S9 configuration detected' >> /tmp/pre.log            	
		return 1
	fi 
	echo 'Series S7 configuration detected' >> /tmp/pre.log
	return 0
}

function check_nwx_raid
{
     	# get raid adapter count
	local numadp=`$COMMAND_TOOL -adpcount  | grep -i 'Controller Count:' | awk -F: '{print $2}'`
	let numadp="${numadp%.}"
	# if more than one get PERC ID
	if [[ $numadp -gt 1 ]]; then
		local count
		local percID
		let count=0
		while [[ $count -lt $numadp ]]
		do
			if [[ `$COMMAND_TOOL -adpallinfo -a$count | grep -i 'Product Name' | grep -i 'PERC H700 Integrated'` ]]; then
				percID=$count
				echo "$count" > /tmp/intAdapterId
				break
			fi
		let count=$count+1
		done
		# Intel NWX has integrated RAID controller at ID: 0
		if ! [ $percID ]; then
			percID=0
		fi	
	else
		percID='0'
		echo "$percID" > /tmp/intAdapterId
	fi 
	
	# check number of virtual drives on PERC
	local numLD
	let numLD=`$COMMAND_TOOL -adpallinfo -a$percID | grep -i 'Virtual *Drives' | awk '{print $4}'`
	if [ $numLD -ne 2 ]
	then
		echo "Invalid or no RAID configuration found: #LD = $numLD" >> /dev/tty2
                echo "Applying new RAID configuration" >> /dev/tty2 
		return 1
        fi

	# verify virtual drive configuration
	let count=0
	local raidLevel
	local numDrives
	while [ $count -lt $numLD ]
	do
		raidLevel=`$COMMAND_TOOL -ldinfo -l$count -a$percID | grep -i 'RAID Level:' | awk '{print $3}'`
		numDrives=`$COMMAND_TOOL -ldinfo -l$count -a$percID | grep -i 'Number Of Drives:' | awk -F: '{print $2}'` 
		if ! [[ `echo $raidLevel | grep -i 'Primary-1'` ]] && [ "$numDrives" != '2' ]
		then
			echo "Invalid or no RAID configuration found: RAID Level = $raidLevel #HDD = $numDrives" >> /dev/tty2
			echo "Applying new RAID configuration" >> /dev/tty2 
			return 1
		fi
		let count=$count+1
	done 
	
	return 0
}

function check_s5_hybrid_raid
{
	# check RAID configuration
	local numLD=`$COMMAND_TOOL -adpallinfo -a0 | grep -i 'Virtual *Drives' | awk '{print $4}'`
	if [ "$numLD" != 5 ]
	then
		echo "Invalid or no RAID configuration found: #LD = $numLD" >> /dev/tty2
                echo "Applying new RAID configuration" >> /dev/tty2 
		return 1
        fi

	local count
	let count=0
	local raidLevel
	local numDrives
	while [ $count -lt 5 ]
	do
		if [ $count -eq 0 ]; then
			raidLevel=`$COMMAND_TOOL -ldinfo -l$count -a0 | grep -i 'RAID Level:' | awk '{print $3}'`
			numDrives=`$COMMAND_TOOL -ldinfo -l$count -a0 | grep -i 'Number Of Drives:' | awk -F: '{print $2}'` 
			if ! [[ `echo $raidLevel | grep -i 'Primary-1'` &&  "$numDrives" = '2' ]]
			then
				echo "Invalid or no RAID configuration found: RAID Level = $raidLevel #HDD = $numDrives" >> /dev/tty2
				echo "Applying new RAID configuration" >> /dev/tty2 
				return 1
			fi

		elif [ $count -eq 1 ]; then
			raidLevel=`$COMMAND_TOOL -ldinfo -l$count -a0 | grep -i 'RAID Level:' | awk '{print $3}'`
			numDrives=`$COMMAND_TOOL -ldinfo -l$count -a0 | grep -i 'Number Of Drives:' | awk -F: '{print $2}'` 
			if ! [[ `echo $raidLevel | grep -i 'Primary-1'` &&  "$numDrives" = '2' ]]
			then
				echo "Invalid or no RAID configuration found: RAID Level = $raidLevel #HDD = $numDrives" >> /dev/tty2
				echo "Applying new RAID configuration" >> /dev/tty2 
				return 1
			fi
		elif [ $count -eq 2 ]; then
			raidLevel=`$COMMAND_TOOL -ldinfo -l$count -a0 | grep -i 'RAID Level:' | awk '{print $3}'`
			numDrives=`$COMMAND_TOOL -ldinfo -l$count -a0 | grep -i 'Number Of Drives:' | awk -F: '{print $2}'` 
			if ! [[ `echo $raidLevel | grep -i 'Primary-5'` &&  "$numDrives" = '4' ]]
			then
				echo "Invalid or no RAID configuration found: RAID Level = $raidLevel #HDD = $numDrives" >> /dev/tty2
				echo "Applying new RAID configuration" >> /dev/tty2 
				return 1
			fi 
		elif [ $count -eq 3 ]; then
			raidLevel=`$COMMAND_TOOL -ldinfo -l$count -a0 | grep -i 'RAID Level:' | awk '{print $3}'`
			numDrives=`$COMMAND_TOOL -ldinfo -l$count -a0 | grep -i 'Number Of Drives:' | awk -F: '{print $2}'` 
			if [ -z $1 ]; then
				if ! [[ `echo $raidLevel | grep -i 'Primary-5'` &&  "$numDrives" = '3' ]]
				then
					echo "Invalid or no RAID configuration found: RAID Level = $raidLevel #HDD = $numDrives" >> /dev/tty2
					echo "Applying new RAID configuration" >> /dev/tty2 
					return 1
				fi
			else
				if ! [[ `echo $raidLevel | grep -i 'Primary-5'` &&  "$numDrives" = '4' ]]
				then
					echo "Invalid or no RAID configuration found: RAID Level = $raidLevel #HDD = $numDrives" >> /dev/tty2
					echo "Applying new RAID configuration" >> /dev/tty2 
					return 1
				fi
			fi
 		else	
			raidLevel=`$COMMAND_TOOL -ldinfo -l$count -a0 | grep -i 'RAID Level:' | awk '{print $3}'`
			numDrives=`$COMMAND_TOOL -ldinfo -l$count -a0 | grep -i 'Number Of Drives:' | awk -F: '{print $2}'` 
			if ! [[ `echo $raidLevel | grep -i 'Primary-1'` &&  "$numDrives" = '2' ]]
			then
				echo "Invalid or no RAID configuration found: RAID Level = $raidLevel #HDD = $numDrives" >> /dev/tty2
				echo "Applying new RAID configuration" >> /dev/tty2 
				return 1
			fi	
		fi
		let count=$count+1
	done 
	
	return 0
}

function check_mpbrok_raid
{
	# check RAID configuration
	local numLD=`$COMMAND_TOOL -adpallinfo -a0 | grep -i 'Virtual *Drives' | awk '{print $4}'`
	if [ "$numLD" != 2 ]
	then
		echo "Invalid or no RAID configuration found: #LD = $numLD" >> /dev/tty2
                echo "Applying new RAID configuration" >> /dev/tty2 
		return 1
        fi

	local count
	let count=0
	local raidLevel
	local numDrives
	while [ $count -lt 2 ]
	do
		if [ $count -lt 1 ]; then
			raidLevel=`$COMMAND_TOOL -ldinfo -l$count -a0 | grep -i 'RAID Level:' | awk '{print $3}'`
			numDrives=`$COMMAND_TOOL -ldinfo -l$count -a0 | grep -i 'Number Of Drives:' | awk -F: '{print $2}'` 
			if ! [[ `echo $raidLevel | grep -i 'Primary-5'` &&  "$numDrives" = '3' ]]
			then
				echo "Invalid or no RAID configuration found: RAID Level = $raidLevel #HDD = $numDrives" >> /dev/tty2
				echo "Applying new RAID configuration" >> /dev/tty2 
				return 1
			fi
		else
			raidLevel=`$COMMAND_TOOL -ldinfo -l$count -a0 | grep -i 'RAID Level:' | awk '{print $3}'`
			numDrives=`$COMMAND_TOOL -ldinfo -l$count -a0 | grep -i 'Number Of Drives:' | awk -F: '{print $2}'` 
			if ! [[ `echo $raidLevel | grep -i 'Primary-5'` &&  "$numDrives" = '6' ]]
			then
				echo "Invalid or no RAID configuration found: RAID Level = $raidLevel #HDD = $numDrives" >> /dev/tty2
				echo "Applying new RAID configuration" >> /dev/tty2 
				return 1
			fi 	
		fi
		let count=$count+1
	done 
	
	return 0
}
 
function check_esa_raid
{
	# check RAID configuration
	local numLD=`$COMMAND_TOOL -adpallinfo -a0 | grep -i 'Virtual *Drives' | awk '{print $4}'`
	if [ "$numLD" != 1 ]
	then
		echo "Invalid or no RAID configuration found: #LD = $numLD" >> /dev/tty2
                echo "Applying new RAID configuration" >> /dev/tty2 
		return 1
        fi

	local count
	let count=0
	local raidLevel
	local numDrives
	
	while [ $count -lt 1 ]
	do
		raidLevel=`$COMMAND_TOOL -ldinfo -l$count -a0 | grep -i -E 'RAID[[:space:]]+Level[[:space:]]+:' | awk '{print $4}'`
		numDrives=`$COMMAND_TOOL -ldinfo -l$count -a0 | grep -i -E 'Number[[:space:]]+Of[[:space:]]+Drives[[:space:]]+:' | awk '{print $5}'` 
		if ! [[ `echo $raidLevel | grep -i 'Primary-5'` &&  "$numDrives" = '9' ]]
		then
			echo "Invalid or no RAID configuration found: RAID Level = $raidLevel #HDD = $numDrives" >> /dev/tty2
			echo "Applying new RAID configuration" >> /dev/tty2 
			return 1
		fi
		let count=$count+1
	done 
	
	return 0
}

function check_s7_esa_raid
{
	# check RAID configuration
	local numLD=`$COMMAND_TOOL -adpallinfo -a0 | grep -i 'Virtual *Drives' | awk '{print $4}'`
	if [ "$numLD" != 2 ]
	then
		echo "Invalid or no RAID configuration found: #LD = $numLD" >> /dev/tty2
                echo "Applying new RAID configuration" >> /dev/tty2 
		return 1
        fi

	local count
	let count=0
	local raidLevel
	local numDrives
	while [ $count -lt 2 ]
	do
		if [ $count -eq 0 ]; then
			raidLevel=`$COMMAND_TOOL -ldinfo -l$count -a0 | grep -i 'RAID Level:' | awk '{print $3}'`
			numDrives=`$COMMAND_TOOL -ldinfo -l$count -a0 | grep -i 'Number Of Drives:' | awk -F: '{print $2}'` 
			if ! [[ `echo $raidLevel | grep -i 'Primary-1'` &&  "$numDrives" = '2' ]]
			then
				echo "Invalid or no RAID configuration found: RAID Level = $raidLevel #HDD = $numDrives" >> /dev/tty2
				echo "Applying new RAID configuration" >> /dev/tty2 
				return 1
			fi
		elif [ $count -eq 1 ]; then
			raidLevel=`$COMMAND_TOOL -ldinfo -l$count -a0 | grep -i 'RAID Level:' | awk '{print $3}'`
			numDrives=`$COMMAND_TOOL -ldinfo -l$count -a0 | grep -i 'Number Of Drives:' | awk -F: '{print $2}'` 
			if ! [[ `echo $raidLevel | grep -i 'Primary-5'` &&  "$numDrives" = '3' ]]
			then
				echo "Invalid or no RAID configuration found: RAID Level = $raidLevel #HDD = $numDrives" >> /dev/tty2
				echo "Applying new RAID configuration" >> /dev/tty2 
				return 1
			fi	
		fi
		let count=$count+1
	done 
	
	return 0
}
function promptReboot
{
	chvt 8 
	exec < /dev/tty8 > /dev/tty8 2> /dev/tty8
	echo
	if ! [ -z $1 ]; then
		echo "Run installation again after restart"
	fi
        echo "Press enter to reboot"
	read
	chvt 1
	reboot
}

function chk4_nwx_intel_eusb {
	local eusb=
	if ! [ -z $1 ]; then
	       eusb=1
	fi	       
	local blockdev=( `ls /sys/block | grep 'sd[a-z]'` ) 
	local numusb
	local usbcount
	if [ $eusb ]; then
		if [[ `grep  -A1 '^ *install' /run/install/ks.cfg | grep 'harddrive'` ]]; then
			let numusb=2
		else
			let numusb=1
		fi 
	else
		if [[ `grep  -A1 '^ *install' /run/install/ks.cfg | grep 'harddrive'` ]]; then
			let numusb=1
		else
			let numusb=0
		fi 
	fi
	let usbcount=0        
	for device in ${blockdev[@]}
	do
		if [[ `ls -l /sys/block/$device | grep -i '/usb[0-9]*/'` ]]; then
			let usbcount=$usbcount+1
		fi
	done
	
	if [ $eusb ]; then
		if [ $usbcount -lt $numusb ]; then
			chvt 8 
			echo
			echo " Only $usbcount of the $numusb required USB block devices found"
			echo " This kickstart is for intel nwx systems with a eUSB device"
	       		echo " Please install/verify the eUSB device and re-install"
			echo " Halting system in 60 seconds ..."
			sleep 60
			halt -p
		fi 
	else	
		if [ $usbcount -gt $numusb ]; then
			chvt 8 
			echo
			echo " Found $usbcount USB block devices, only $numusb are allowed"
			echo " This kickstart is for intel nwx systems without a eUSB device"
	       		echo " Please remove the eUSB device and re-install"
			echo " Halting system in 60 seconds ..."
			sleep 60
			halt -p
		fi
	fi
} 

function check_return {
	return 0
}

# call raid hba configuration script
function initRaid {
	/tmp/initraid.sh
}

function clearRaidPrompt {
	local usrchoice
	chvt 8
	exec < /dev/tty8 > /dev/tty8 2> /dev/tty8
	echo
	echo '--------------------------------------------'
	echo ' The current drive configuration is invalid'
	echo " for the selected appliance: $nwapptype"
	echo ' The system will auto restart in 30 seconds'
	echo ' If upgrading please verify that you have'
	echo ' selected the correct menu item'
	echo
	echo ' Enter (y/Y) to continue the installation'
	echo ' NOTE: this will clear the existing disks'
	echo ' *Discarding All Data* and is Irreversible'
	echo '--------------------------------------------'
		read -t 30 -p 'Enter Y to Continue, Restart in 30 seconds? ' usrchoice
	if [[ $usrchoice = y || $usrchoice = Y ]]; then
	       return 0
	else
 		exit 1
	fi
}

function prehwimgsrv {
	# enable sshd daemon in %pre install if pxe image testing is detected
	
	local cfgpath='/etc/ssh'
	local keyfile="${cfgpath}/ssh_host_rsa_key"
	local keyfilepub="${cfgpath}/ssh_host_rsa_key.pub"
	local sshd_config="${cfgpath}/sshd_config"
	local mysshd_config='Port 22\nHostKey /etc/ssh/ssh_host_rsa_key\nPermitRootLogin yes\nIgnoreRhosts yes\nStrictModes yes\nX11Forwarding yes\nX11DisplayOffset 10\nPrintMotd yes\nXAuthLocation /sbin/xauth\nKeepAlive yes\nSyslogFacility AUTHPRIV\nRSAAuthentication yes\nPasswordAuthentication yes\nPermitEmptyPasswords yes\nPermitUserEnvironment yes' 
        local hostkey='-----BEGIN RSA PRIVATE KEY-----\nMIIEoAIBAAKCAQEAtRki+qm3GpRyJAfRRPekqmV2EKbm9P+ANZxUxyMAz6MGdXXV\nVU36JJ5HZ6fzIfMsj3sli0m2VzVmGtot3R+J0bOQX3z73l+13ApGafAke6sJXFMf\nrwgsP8P1FMNSE/ogjLYe6T9qcy0HwHd6SL8CwrWg00ezuyhAiFSNPlUKSD7HMg1S\ntZtYy/SC8k8a2yO4POj9zk+lk2Vggn9qvlctAaQfqxUfJs9jXO9/m4JYEgL2x4wO\nnzjK8Y+PEkKZRItGqjd1Vd2uIc7ko2PQwbw34/nJzYhjTEYutl5HEy8YsiyYJNtr\nBlBCLV9w+0vePrst6J0SsMZvPeUGm8b0+i5cGQIBIwKCAQApZNTLlIGfrObjqgPy\ngb884/26qc5j4qD2T55ZZxYg1M5Gu9j9jiqMBuu/69/NPuWdI3ZLuRO8KXZsiaQV\nSQmPBHjFXmV0qCmRYW8uKELacDynY3T0zqsHQrus+XHYrjNTXNPditaAudXi2XsJ\nUDslMNRNjLtd+pJoTdckMLHkoD/I9BcrQ1S6+i12RB24/F/Hnjmv/pmP8e3qOohp\nsPKNdDW06/Zu0BfYtMOYgv3AOZ/zjQpkrEJhZOAbiBknChXgL4SwwWKq1ER6nclH\n7RfaY/YGGvY4vDs+V/A8FiWu8u7wXPS3+oc8TW5Iqfn/+B0Acxkckmw4h+rHpXvm\n++nrAoGBAOoTj/iAetHjzCYr9sLZ+ykjOdyUFRhaBjrYa0dzagEd6oF4halPVMgp\n8s6RQZd0eN1KGnD+1+HkdDjA270FEt2g/OF5b6aRrpCG4Howun76bU9aptzZjJkY\ne4mN1XG+KBYdsntUNCAdB6pynBFojbvJ1eULr4HrpCqAt/n5QtDTAoGBAMYPUXTX\n2fQ2IdXg7lX32GwQWuTYQK1jnLTJVA58hwa43TM7Bx+yrDLe5dlPA6p0jf2z6JAn\n70ajAgHY8240rElUaq9XH/fkv6iEEQX2VHCOFyYYK5E6ghJtIgJ+eMIWnayrkkEN\nNBJohQQKyCcWT/M8z5/IFlPa7jjxmvzuXWvjAoGAFBBOKz42acMRf51eSzdBae0T\nlpBZlF984HjzQKN+HVpV7dchZkig3fT3jgxzVh/tGkguJvFFtEbIIh8oxw8QPuHp\nyi768QUsOEYTPaxnwb2xmRZmEu4TXZRiXD9bcCY980RfwW2eEWGS8VpH5DwpZ94Z\npesPCyLTjp1RmRVdf50CgYAy7f8AycpUvXZqMoZt4KVdnc462IWo7bqU41Ag+3Mt\nnUAxvriwYST3I1+s6G6oLJmKYXZQ9FN4kFD5KSinT1+AkgzOAHXvSXMctD7kRqf/\nr4JLn9CwUN+eVpO3f5tlG8IlFizsJ/dycqXcd80RXYJF3G/nQhRetKOoPiCKLqpO\n8QKBgCjfxkjN5/bAIVyP8YzPIY8yt2kFNC0uNNBQ3trWfvFnZsxh22uaWIPCTdyL\nU7CRxw/1t5u7gC3NHzLBiKATvBRvLEi9cOoSaNFJjEzhG7/07VrknJ/OFj2nGcIn\ncof3Np/4KH4z6j9D49HxLoHfzEiqcHdtFWjVCCdrG7ruYh1G\n-----END RSA PRIVATE KEY-----'	
	local hostkeypub='ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAtRki+qm3GpRyJAfRRPekqmV2EKbm9P+ANZxUxyMAz6MGdXXVVU36JJ5HZ6fzIfMsj3sli0m2VzVmGtot3R+J0bOQX3z73l+13ApGafAke6sJXFMfrwgsP8P1FMNSE/ogjLYe6T9qcy0HwHd6SL8CwrWg00ezuyhAiFSNPlUKSD7HMg1StZtYy/SC8k8a2yO4POj9zk+lk2Vggn9qvlctAaQfqxUfJs9jXO9/m4JYEgL2x4wOnzjK8Y+PEkKZRItGqjd1Vd2uIc7ko2PQwbw34/nJzYhjTEYutl5HEy8YsiyYJNtrBlBCLV9w+0vePrst6J0SsMZvPeUGm8b0+i5cGQ== root@localhost.localdomain'

	if [[ `dmesg | grep -E -i 'Kernel[[:space:]]+command[[:space:]]+line:' | grep "ks=http://${pxetesthost}"` ]]; then 
		echo "prehwimgsrv() enabling sshd daemon for pxe image testing" | tee -a /tmp/pre.log
		pxeimgtest='true'
		echo -e ${mysshd_config} > ${sshd_config}
		chmod 644 ${sshd_config}
		echo ${hostkeypub} > ${keyfilepub}
		chmod 644 ${keyfilepub} 
		echo -e ${hostkey} > ${keyfile}
		chmod 600 ${keyfile}
		/sbin/sshd | tee -a /tmp/pre.log
	fi
}

# run hardware verification tests
function doAllSeriesCheck
{ 
	echo "running doAllSeriesCheck" >> /tmp/pre.log
	
	local count
	
	# determine hardware type
	let count=0
	while ! [ $nwsystem ]
	do
		set_nwsystem
		let count=$count+1
		sleep 1
		if [ $count -gt 4 ]; then
			break
		fi
	done 
	
	# un-qualified hardware, exit
	if ! [ $nwsystem ]; then
		invalid_hw
	fi

#	# determine appliance type
	let count=0
	while ! [ $nwapptype ]
	do
		set_nwapptype
		let count=$count+1
		sleep 1
		if [ $count -gt 4 ]; then
			break
		fi
	done
#	
	# unknown appliance type, exit
	if ! [ $nwapptype ]; then 
		echo
		echo "--------------------------------------------"
		echo " unable to determine appliance install type"
		echo " no installation/upgrade method available"
		echo "--------------------------------------------"
		echo
		promptReboot
	fi

#	nwapptype=bootstrap
	
	# determine drive checks, package list and %post script per hardware and appliance type
	set_raid_packs_post
	sleep 5
	
	# run drive checks: $drivetest, test and configure raid: $drivetest2 
	# systems with no hardware raid
	if ! [ $hwraid ] && [ $drivetest ]; then
		echo 'running check option 1, no hw raid' >> /tmp/pre.log
		echo "\$drivetest = $drivetest" >> /tmp/pre.log
		if ! $drivetest
		then
			promptReboot
		fi 
	elif [[ $hwraid && $drivetest ]] && ! [ $drivetest2 ]; then
		echo 'running check option 2, with hw raid' >> /tmp/pre.log
		echo "\$drivetest = $drivetest" >> /tmp/pre.log	
		if ! $drivetest
		then
			if ! [ $pxeimgtest ]; then
				if ! [ -e /tmp/nwusrclear ]; then
					clearRaidPrompt
					clrRaidCfg auto
				fi
				initRaid
				promptReboot cfgclr
				chvt 1
				return 1
			else
				clrRaidCfg auto
                                initRaid
                                echo 'rebooting system in 15 seconds'
                                sleep 15
                                reboot
			fi
		fi
	# if two drive tests are required, make raid config check second in order
	elif [[ $hwraid && $drivetest && $drivetest2 ]]; then
		echo 'running check option 3, with hw raid' >> /tmp/pre.log
		echo "\$drivetest = $drivetest" >> /tmp/pre.log	
		echo "\$drivetest2 = $drivetest2" >> /tmp/pre.log	
		if ! $drivetest
		then
			promptReboot
		fi	
		if ! $drivetest2
		then
			if ! [ $pxeimgtest ]; then			
				if ! [ -e /tmp/nwusrclear ]; then
					clearRaidPrompt
					clrRaidCfg auto
				fi
				initRaid
				promptReboot cfgclr
			else
				clrRaidCfg auto
                                initRaid
                                echo 'rebooting system in 15 seconds'
                                sleep 15
                                reboot
			fi
		fi 
	fi 
	return 0
}

function clrRaidCfg {
# re-label disks, clear raid hba configuration
	local devices
	local drive
	local drives 
	local automode
	local adpID 
	local count 
	local COMMAND_TOOL="${COMMAND_TOOL}"
	local adpNum=`$COMMAND_TOOL -adpcount | grep -i 'Controller Count' | awk -F: '{print $2}' | awk '{print $1}'`
	let adpNum=${adpNum%.}
	local ctrlname
	local vdisk
	local pdisk
	local usrInput
	if ! [ -z $1 ]; then
		automode=$1
	fi 
	
	# check for pxe image testing
	prehwimgsrv
	
	if [ $adpNum -gt 0 ]; then
		if ! [ $nwsystem ]; then
			set_nwsystem
		fi
		# on the dell r610 with dual raid adapters the integrated perc shows up as id: 1
		if [[ $nwsystem = dell-s4-1u  ]]; then
			# if more than one get PERC ID
			if [[ $adpNum -gt 1 ]]; then
				let count=0
				while [[ $count -lt $adpNum ]]
				do
					if [[ `$COMMAND_TOOL -adpallinfo -a$count | grep -i 'Product Name' | grep -i 'PERC H700 Integrated'` ]]; then
						adpID=$count
						echo "$count" > /tmp/intAdapterId
						break
					fi
					let count=$count+1
				done
			else
				adpID='0'
			fi
		else
			adpID='0'
		fi 
	fi
	
	# get block device list for relabeling, *Need to check for DRAC devices*
	detect_install_devices
	echo -n "installdev = " >> /tmp/pre.log
	echo "${installdev[@]}" >> /tmp/pre.log
	echo -n "installmodel = " >> /tmp/pre.log
	echo "${installmodel[@]}" >> /tmp/pre.log
	#drives=( `ls -A /sys/block | grep '[hs]d[a-z]'` )
	#let count=0
	#for drive in ${drives[@]}	
	#do
	#	# skip usb block devices other than dell r620 sd cards
	#	if [[ `ls -l /sys/block/$drive | grep -E -i '/usb[[:digit:]]*/'` ]] && ! [[ `cat /sys/block/$drive/device/model | grep -i -E 'Internal[[:space:]]+Dual[[:space:]]+SD'` ]]; then
	#		echo > /dev/null	
	#	else
	#		devices[$count]=$drive
	#		let count=$count+1
	#	fi
	#done
	chvt 8 
	exec < /dev/tty8 > /dev/tty8 2> /dev/tty8
	if ! [ $automode ]; then
		ctrlname=`$COMMAND_TOOL -adpallinfo -a$adpID | grep -i -E 'Product[[:space:]]+Name' | awk -F: '{print $2}'`
		vdisk=`$COMMAND_TOOL -adpallinfo -a$adpID | grep -i -E 'Virtual[[:space:]]+Drives' | awk -F: '{print $2}'`
		pdisk=`$COMMAND_TOOL -adpallinfo -a$adpID | grep -A1 -i -E 'Physical[[:space:]]+Devices' | grep -i 'Disks' | awk -F: '{print $2}'`
		usrInput='n' 
		echo
		echo
		if [ $adpNum -gt 0 ]; then
			echo '------------------------------------------------------------'
			echo "  Clear virtual drive configuration on RAID controller: $adpID ?"
			echo "  HBA:$ctrlname #VD:$vdisk #PD:$pdisk" 
			echo "  For Upgrades either ignore or answer No to this prompt"
			echo "  Recommended for new hardware or re-purposing **Warning**"
			echo "  data on all configured drives will be discarded, this"
			echo "  includes internal SATA/SCSI storage and attached external"
			echo "  RAID storage on applicable cards, i.e. JBOD enclosures"
			echo "  Enter (y/Y) to clear drives, defaults to No in 30 seconds"
			echo '------------------------------------------------------------'
		else
			echo '------------------------------------------------------------'
			echo "  Clear the drive contents from all physical disks ?"
			echo "  For Upgrades either ignore or answer No to this prompt"
			echo "  Recommended for new hardware or re-purposing"
			echo "  ** Warning ** data on all local disks will be discarded"
			echo "  Enter (y/Y) to clear drives, defaults to No in 30 seconds"
			echo '------------------------------------------------------------'
		fi

		read -t 30 -p "? " usrInput
		echo ''
		echo "usrInput = |${usrInput}|" >> /tmp/pre.log
		if [[ $usrInput = "y" || $usrInput = "Y" ]]; then
			echo 'cleardrives=1' > /tmp/nwusrclear
			echo "  Clearing drive configuration in 15 seconds, <CTRL><ALT><DEL> to cancel"
			echo "  Ignore or answer no to this prompt after restarting"
			sleep 15 
			echo "  Re-labeling disks and virtual drives, clearing RAID configuration ..."
			# clear partition tables
			#mk_disk_labels ${devices[@]}
			mk_disk_labels ${installdev[@]}
			# clear raid configuration
			if [ $adpNum -gt 0 ]; then
				$COMMAND_TOOL -CfgClr -a$adpID 
				if [[ $? != 0 ]]; then
					echo " CfgClr returned non zero exit status, retry in 10 seconds"
					sleep 10 
					$COMMAND_TOOL -CfgClr -a$adpID
				fi
			fi
		else
			return 0	
		fi
	else
		echo
		echo "  Clearing drive configuration in 15 seconds, <CTRL><ALT><DEL> to cancel"
		echo "  Ignore or answer no to this prompt after restarting"
		sleep 15 
		echo "  Re-labeling disks and virtual drives, clearing RAID configuration ..."
		# clear partition tables
		#mk_disk_labels ${devices[@]}
		mk_disk_labels ${installdev[@]}	
		# clear raid configuration
		if [ $adpNum -gt 0 ]; then
			$COMMAND_TOOL -CfgClr -a$adpID 
			if [[ $? != 0 ]]; then
				echo " CfgClr returned non zero exit status, retry in 10 seconds"
				sleep 10 
				$COMMAND_TOOL -CfgClr -a$adpID
			fi
		fi

	fi
	chvt 1
}


